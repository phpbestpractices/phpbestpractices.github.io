<!doctype html>
<html lang="pt_BR">
    <head>
        <!-- EN-Revision: 37c7eea0a03a9129fb99e3e9355b05daa80d826e -->
        <title>PHP Melhores Práticas: um guia curto e prático para tarefas comuns e confusas no PHP</title>
        
        <meta charset="utf-8" />
        
        <link type="text/css" rel="stylesheet" href="css/core.css" media="screen" />
        <link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCore.css" media="screen" />
        <link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCoreDefault.css" media="screen" />
        
        <script type="text/javascript" src="js/jquery/jquery-1.7.2.min.js"></script>
        <script type="text/javascript" src="js/jquery/jquery.smooth-scroll-1.4.5.min.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shCore.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shBrushPhp.js"></script>
        
        <script type="text/javascript">
            $(document).ready(function(){
                $('code.php').attr('class', 'php brush: php');
                SyntaxHighlighter.config.tagName = 'code';
                SyntaxHighlighter.all()

                $('a').smoothScroll();

                $(window).scroll(function(){
                    UpdateToc();
                });

                // For some reason, without a timeout this doesn't set the right toc entry on load.
                // Timeout fixes this.  Must be a page layout timing issue.
                setTimeout(function(){ UpdateToc(); }, 500);
            });

            function UpdateToc(){
                var windowTop = $(window).scrollTop();
                var closestSectionId = '';
                var closestSectionTop = 0;

                $('section').each(function(){
                    if($(this).offset().top > closestSectionTop && $(this).offset().top <= windowTop + 40){
                        closestSectionTop =  $(this).offset().top;
                        closestSectionId = $(this).attr('id');
                    }
                });

                $('nav a').removeClass('highlighted');
                $('nav a[href$="' + closestSectionId + '"]').addClass("highlighted");

                if(windowTop > $('nav').offset().top)
                    $("nav").addClass("sticky");

                if(windowTop < 130)
                    $("nav").removeClass("sticky");
            }
        </script>
        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-35543520-1', 'phpbestpractices.org');
            ga('send', 'pageview');
        </script>
    </head>
    <body>
        <h1>PHP Melhores Práticas <span>Um guia curto e prático para tarefas comuns e confusas no PHP</span>
        <span class="translations"><a href="index.html">en</a> | <a href="index.pt_BR.html">pt_BR</a></span></h1>

        
        <nav>
            <ol>
                <li><a href="#maintainers">Última revisão &amp; mantenedores</a></li>
                <li><a href="#introduction">Introdução</a></li>
                <li><a href="#version">Que versão do PHP você está usando?</a></li>
                <li><a href="#passwords">Armazenando senhas</a></li>
                <li><a href="#mysql">PHP e MySQL</a></li>
                <li><a href="#php-tags">Tags PHP</a></li>
                <li><a href="#auto-loading">Autoloading de classes</a></li>
                <li><a href="#quotes">Aspas duplas versus aspas simples</a></li>
                <li><a href="#constants">define() versus const</a></li>
                <li><a href="#opcode-cache">Cache de opcode PHP</a></li>
                <li><a href="#memcached">PHP e Memcached</a></li>
                <li><a href="#regex">PHP e regex</a></li>
                <li><a href="#serving-php">Servindo o PHP</a></li>
                <li><a href="#email">Envio de email</a></li>
                <li><a href="#validating-emails">Validação de endereços de email</a></li>
                <li><a href="#sanitizing-html">Sanitização de HTML</a></li>
                <li><a href="#utf-8">PHP e UTF-8</a></li>
                <li><a href="#working-with-dates-and-times">Trabalhando com datas e horários</a></li>
                <li><a href="#checking-for-null">Verificando valores null e false</a></li>
                <li><a href="#suggestions">Sugestões e correções</a></li>
            </ol>
        </nav>
        
        <article>
            <section id="maintainers">
                <h2>Última revisão &amp; mantenedores</h2>
                <p>O original em inglês deste documento foi revisado pela última vez em 3 de julho de 2014. Ele foi alterado pela última vez em 3 de julho de 2014.</p>
                <p>O original em inglês é mantido por <a href="https://alexcabal.com">Alex Cabal</a>.
                <p><a href="https://alexcabal.com/contact/">Converse com ele</a> se achar que ele possa te ajudar em algo, ou ainda se tiver sugestões ou correções para o documento original em inglês.</p>
            </section>
        
            <section id="introduction">
                <h2>Introdução</h2>
                <p>O PHP é uma linguagem complexa que, por anos, sofreu com reviravoltas, mudanças de direções, extensões forçadas e hacks. Ele é bastante inconsistente e, às vezes, até bugado. Cada versão é única com suas funcionalidades, estranhezas e peculiaridades, e fica difícil acompanhar que versão tem quais problemas. É fácil entender por que ele é tão odiado de vem em quando.</p>
                <p>Apesar disso, ele é a linguagem mais popular da web atualmente. Por causa da sua longa história, você encontrará um grande número de tutoriais de como fazer as coisas básicas, como criptografia de senhas e acesso a bancos de dados. O problema é que você tem uma chance bem grande de, em cinco tutoriais, encontrar cinco jeitos diferentes de se fazer cada uma dessas coisas. Qual deles é o jeito "certo"? Algum dos outros jeitos tem bugs escondidos ou armadilhas? É realmente bem difícil de saber e você ficará vagando eternamente na internet em busca da resposta perfeita.</p>
                <p>Essa também é uma das razões que fazem com que novos programadores PHP sejam frequentemente criticados por código feio, ultrapassado e inseguro. Mas eles não podem melhorar isso se o primeiro resultado de uma busca no Google for um artigo de quatro anos atrás ensinando uma técnica de cinco anos atrás!</p>
                <p>Este documento tenta mirar nesse problema. Ele é uma tentativa de compilar um conjunto de instruções básicas para o que podem ser consideradas melhores práticas para problemas e tarefas comuns no PHP. Se uma tarefa de baixo nível tem muitas soluções possíveis e confusas no PHP, ela deve estar aqui.</p>
        
                <h4>O que é</h4>
                <p>Este é um guia sugerindo a melhor direção a tomar quando você der de cara com uma das tarefas de <em>baixo nível</em>, que um programador PHP frequentemente deve encontrar, e que sejam pouco claras em virtude das muitas opções que o PHP oferece. Por exemplo: conectar com um banco de dados é uma tarefa frequente com uma gama enorme de soluções possíveis em PHP, nem todas sendo tão boas assim &mdash; por isso, ela está aqui neste documento.</p>
                <p>Esta é uma série de soluções pequenas e introdutórias. Os exemplos devem te entregar tudo que precisa para configurações básicas. Você deve fazer sua própria pesquisa para torná-las algo útil para você.</p>
                <p>Ele mostra o que consideramos o PHP mais moderno possível. No entanto, isso significa que se você estiver usando uma versão mais antiga do PHP, algumas das funcionalidades necessárias para se aproveitar das soluções daqui podem não estar disponíveis para você.</p>
                <p>Este é um documento vivo e faremos o melhor possível para mantê-lo atualizado com a constante evolução do PHP.</p>

                <h4>O que <em>não é</em></h4>
                <p>Este documento não é um tutorial de PHP. Você deve aprender as questões básicas de sintaxe da linguagem em algum outro lugar.</p>
                <p>Não é um guia para problemas comuns das aplicações web, como armazenamento de cookies, cache, estilo de código, documentação etc.</p>
                <p>Não é um guia de segurança. Apesar de abordar algumas questões relacionadas à segurança, é esperado que você faça sua própria pesquisa no tocante à segurança de suas aplicações PHP. Em particular, você deve revisar cuidadosamente qualquer solução proposta aqui antes de implementá-la, afinal, seu código é problema seu.</p>
                <p>Não é um defensor de nenhum estilo de código, padrão de desenvolvimento ou framework.</p>
                <p>Não é um defensor de nenhum modo para realização de tarefas de mais alto nível como gerenciamento de usuários, sistemas de acesso etc. Esse documento é estritamente focado em tarefas de <em>baixo nível</em> que podem ser, devido à longa história do PHP, confusas ou pouco claras.</p>
               <p>Não é a solução definitiva, nem mesmo a <em>única</em> solução. Alguns dos métodos descritos abaixo podem não ser os melhores para sua situação em particular e sempre existem vários jeitos diferentes de se chegar ao mesmo fim. Em particular, aplicações com alto tráfego podem se beneficiar de soluções mais complexas para alguns dos problemas citados.</p>
            </section>
        
        
            <section id="version">
                <h2>Que versão do PHP você está usando?</h2>
                <h3>PHP 5.5.9-1ubuntu4.2, instalado no Ubuntu 14.04 LTS.</h3>
                <p>O PHP é a tartaruga de 100 anos do mundo web. Seu casco está marcado por uma história rica, complicada e retorcida. Num ambiente de hospedagem compartilhada, a configuração dele pode restringir suas possibilidades.</p>
                <p>A fim de mantermos um pouco de sanidade, vamos focar apenas em uma versão do PHP. Em 30 de abril de 2014, essa versão é a <strong>PHP 5.5.9-1ubuntu4.2</strong>. Essa é a versão instalada usando o apt-get num servidor <strong>Ubuntu 14.04 LTS</strong>. Em outras palavras, esse é o padrão seguro que muitos utilizam.</p>
                <p>Talvez você descubra que algumas dessas soluções funcionam em versões diferentes, ou mais antigas, do PHP. Se isso acontecer, <em>cabe a você pesquisar as implicações dos possíveis bugs ou problemas de segurança dessas versões antigas</em>.</p>
                <aside>
                    <h3>Uma nota sobre o Ubuntu 12.04 LTS</h3>
                    <p>Muita coisa mudou no mundo PHP nos anos entre o Ubuntu 12.04 e o 14.04. Como o 12.04 ainda é muito comum, e como algumas das soluções abaixo mudaram de forma significativa no 14.04, incluirei soluções específicas para o 12.04 em uma caixa como esta aqui.</p>
                <p>A versão do PHP instalada no Ubuntu 12.04 usando o apt-get é a <b>PHP 5.3.10-1ubuntu3.6 with Suhosin-Patch</b>.</p>
                </aside>            
            </section>
        
            <section id="passwords">
                <h2>Armazenando senhas</h2>
                <h3>Use as funções embutidas de <a href="http://www.php.net/manual/en/book.password.php">password hashing</a> para fazer hash e comparar senhas.</h3>
                <p>Hash é a maneira padrão de proteger uma senha de usuário antes de armazená-la numa banco de dados. Muitos dos algoritmos comuns, como o md5 ou até o sha1, são inseguros para armazenar senhas porque <a href="http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/">hackers podem facilmente crackear senhas hasheadas com esses algoritmos</a>.</p>
                <p>O PHP fornece uma biblioteca embutida para hash de senhas que usa o algoritmo bcrypt, atualmente considerado o melhor algoritmo para hash de senhas.</p>
                
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Faz o hash da senha.  $hashedPassword será uma string de 60 caracteres.
                $hashedPassword = password_hash('my super cool password', PASSWORD_DEFAULT);
        
                // Agora você pode armazenar de forma segura o conteúdo de $hashedPassword no seu banco de dados!
        
                // Verifica se um usuário forneceu a senha correta comparando o que ele digitou com nosso hash
                password_verify('the wrong password', $hashedPassword); // false
        
                password_verify('my super cool password', $hashedPassword); // true
                ?&gt;</code>
                
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Muitas fontes irão recomendar que você também aplique um "salt" na sua senha antes de fazer o hash. Essa é uma boa ideia, e a função password_hash() <em>já aplica o salt para você</em>. Isso significa que você não precisa aplicar o salt por conta própria.</li>
                </ul>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://blogs.msdn.com/b/lixiong/archive/2011/12/25/md5-sha1-salt-and-bcrypt.aspx">Why hashing passwords with md5 or sha is unsafe (Por que fazer hash de senhas com md5 ou sha é inseguro)</a></li>
                    <li><a href="http://codahale.com/how-to-safely-store-a-password/">How to safely store a password (Como armazenar uma senha de forma segura)</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)<br />
                    Use a biblioteca <a href="http://www.openwall.com/phpass/">phpass</a> para fazer hash e comparar senhas.</h3>
                    <p><em>Testado com o <a href="http://www.openwall.com/phpass/">phpass</a> 0.3.</em></p>
                    <p>A biblioteca de hash de senhas embutida no PHP não está disponível na versão do PHP instalada no Ubuntu 12.04. Em vez dela, utilize a biblioteca open-source <a href="http://www.openwall.com/phpass/">phpass</a>, que fornece a mesma funcionalidade baseada no bcrypt em uma classe fácil de usar.</p>
        
                    <h4>Exemplo</h4>
                    <code class="php">
                    &lt;?php
                    // Inclui a biblioteca phpass
                    require_once('phpass-0.3/PasswordHash.php');
        
                    // Inicializa o hasher sem hashes portáteis (mais seguro)
                    $hasher = new PasswordHash(8, false);
        
                    // Faz o hash da senha.  $hashedPassword será uma string de 60 caracteres.
                    $hashedPassword = $hasher->HashPassword('my super cool password');
        
                    // Agora você pode armazenar de forma segura o conteúdo de $hashedPassword no seu banco de dados!
        
                    // Verifica se um usuário forneceu a senha correta comparando o que ele digitou com nosso hash
                    $hasher->CheckPassword('the wrong password', $hashedPassword); // false
        
                    $hasher->CheckPassword('my super cool password', $hashedPassword); // true
                    ?&gt;</code>
                
                    <h4>Mais informações</h4>
                    <ul>
                        <li><a href="http://www.openwall.com/phpass/">phpass</a></li>
                    </ul>
                    
                    <h4>Pegadinhas</h4>
                    <ul>
                        <li>Assim como na função password_hash() das novas versões do PHP, a biblioteca phpass aplica o salt na sua senha automaticamente para você.</li>
                    </ul>
                </aside>
            </section>
            
            <section id="mysql">
                <h2>Conectando e consultando um banco de dados MySQL</h2>
                <h3>Use a <a href="http://php.net/manual/en/book.pdo.php">PDO</a> e sua funcionalidade de prepared statement.</h3>
                <p>Existem muitas formas de conectar um banco de dados MySQL no PHP. A <a href="http://php.net/manual/en/book.pdo.php">PDO</a> (PHP Data Objects) é a mais nova e robusta delas. A PDO tem uma interface consistente entre vários tipos diferentes de bancos de dados, usa uma abordagem orientada a objetos e suporta mais funcionalidades oferecidas pelos bancos de dados mais novos.</p>
                <p>Você deve usar as funções de prepared statement (instruções preparadas) do PDO para ajudar na prevenção de ataques de SQL injection (injeção de SQL). Usar a função <a href="http://php.net/manual/en/pdostatement.bindvalue.php">bindValue()</a> garante que seu SQL está seguro contra ataques de SQL injection de primeira ordem. (Ela não é 100% segura no entanto, leia <a href="#pdo-further-reading">Mais informações</a> para mais detalhes. ) No passado, isso era conseguido com algumas combinações misteriosas de funções "magic quote". O PDO torna toda aquela gosma desnecessária.</p>
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                try{
                    // Cria uma nova conexão.
                    // Você vai provavelmente querer trocar o hostname por localhost no seu primeiro parâmetro.
                    // Veja que declaramos o charset (codificação de caracteres) como utf8mb4. Isso alerta a conexão de que passaremos dados UTF-8. Talvez nem seja obrigatório dependendo da sua configuração, mas pode te livrar de dores de cabeça se você estiver tentando armazenar strings Unicode em seu banco de dados. Veja "Pegadinhas".
                    // As opções PDO que passamos são as seguintes:
                    // \PDO::ATTR_ERRMODE habilita as exceções para erros. É opcional, mas pode ser útil.
                    // \PDO::ATTR_PERSISTENT desabilita conexões persistentes, que podem causar problemas de concorrência em certos casos. Veja "Pegadinhas".
                    $link = new \PDO(   'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4', 
                                        'your-username', 
                                        'your-password', 
                                        array(
                                            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION, 
                                            \PDO::ATTR_PERSISTENT => false
                                        )
                                    );

                    $handle = $link->prepare('select Username from Users where UserId = ? or Username = ? limit ?');

                    // Bug do PHP: se você não especificar PDO::PARAM_INT, a PDO pode colocar aspas no argumento. Isso pode bagunçar algumas queries do MySQL que não esperam que números inteiros tenham aspas em volta.
                    // Veja: https://bugs.php.net/bug.php?id=44639
                    // Se você não tiver certeza se um valor que está passando é um número inteiro, use a função is_int().
                    $handle->bindValue(1, 100, PDO::PARAM_INT);
                    $handle->bindValue(2, 'Bilbo Baggins');
                    $handle->bindValue(3, 5, PDO::PARAM_INT);

                    $handle->execute();

                    // Usar o método fetchAll() pode ser muito custoso se você estiver consultando um número realmente grande de registros.
                    // Se esse é o caso, você pode usar o método fetch() e percorrer cada resultado num laço linha por linha.
                    // Você também pode retornar arrays e outras coisas em vez de objetos. Veja a documentação da PDO para detalhes.
                    $result = $handle->fetchAll(\PDO::FETCH_OBJ);

                    foreach($result as $row){
                        print($row->Username);
                    }
                }
                catch(\PDOException $ex){
                    print($ex->getMessage());
                }
                ?&gt;</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Não passar o parâmetro PDO::PARAM_INT quando faz o binding de variáveis do tipo integer pode fazer com que o PDO coloque aspas em volta delas às vezes. Isso pode estragar certas queries do MySQL. Veja <a href="https://bugs.php.net/bug.php?id=44639">esse relatório de bug</a>.</li>
                    <li>Não definir o charset como utf8mb4 na sua string de conexão pode fazer com que os dados Unicode sejam armazenados incorretamente no seu banco de dados dependendo de sua configuração.</li>
                    <li>Mesmo se você declarar seu charset como utf8mb4, garanta que suas tabelas reais no banco de dados também estejam. Se quiser saber porque usamos o utf8mb4 em vez de apenas utf8, veja a seção <a href="#utf-8">PHP e UTF-8</a>.</li>
                    <li>Habilitar conexões persistentes possivelmente levará a problemas estranhos relacionados a concorrência. Este não é um problema do PHP, é um problema em nível de aplicação. Conexões persistentes são seguras de se usar desde que você considere as consequências. Veja <a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo"> esta pergunta no Stack Overflow</a>.</li>
                    <li>Você pode executar mais de uma instrução SQL em uma única chamada execute(). Apenas separe as instruções por ponto-e-vírgula. <b>Ubuntu 12.04 (PHP &lt;= 5.3.10):</b> Se fizer isso, cuidado com <a href="https://bugs.php.net/bug.php?id=61207">esse bug</a>, que não foi arrumado na versão do PHP que vem no Ubuntu 12.04.</li>
                </ul>
        
                <h4 id="pdo-further-reading">Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/book.pdo.php">Manual do PHP: PDO</a></li>
                    <li><a href="http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/">Why you should be using PHP's PDO for database access (Por que você deveria usar a PDO do PHP para acesso a banco de dados)</a></li>
                    <li><a href="http://stackoverflow.com/questions/1402017/php-pdo-vs-normal-mysql-connect">Stack Overflow: PHP PDO vs normal mysql_connect</a></li>
                    <li><a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection">Stack Overflow: Are PDO prepared statements sufficient to prevent SQL injection? (Prepared statements da PDO são suficientes para prevenir SQL injection?)</a></li>
                    <li><a href="https://stackoverflow.com/questions/1650591/whether-to-use-set-names">Stack Overflow: Whether to use "SET NAMES" ("SET NAMES" deve ser utilizado?)</a></li>
                </ul>
            </section>

            <section id="php-tags">
                <h2>Tags PHP</h2>
                <h3>Use &lt;?php ?&gt;.</h3>
                <p>Existe um punhado de maneiras diferentes de delimitar blocos de código PHP: &lt;?php ?&gt;, &lt;?= ?&gt;, &lt;? ?&gt;e &lt;% %&gt;. Mesmo que as mais curtas possam ser mais convenientes para digitar, a único que é garantido que funciona em todos os servidores PHP é a &lt;?php ?&gt;. Se você ao menos pensa em fazer deploy da sua aplicação PHP em um servidor cuja configuração você não pode controlar, você deve sempre usar a &lt;?php ?&gt;.</p>
                <p>Se você estiver programando para você mesmo e tiver controle da configuração do PHP que irá usar, você pode achar que as tags mais curtas sejam mais convenientes. Mas lembre-se que &lt;? ?&gt; pode conflitar com declarações XML e &lt;% %&gt; é na verdade a tag do ASP.</p>
                <p>Não importa o que escolher, certifique-se de ser consistente!</p>
            
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Quando incluir uma tag de fechamento ?&gt; em um arquivo de PHP puro (por exemplo, em um arquivo que contém apenas uma definição de classe), <em>certifique-se de não colocar nenhuma quebra de linha depois dela</em>. Apesar do parser do PHP "engolir" de forma segura um caractere único de quebra de linha depois de uma tag de fechamento, outras quebras de linha adicionais podem ser mostradas no navegador e bagunçar as coisas se você for enviar algum cabeçalho HTTP em seguida.</li>
                    <li>Quando escrever uma aplicação web para versões antigas do IE, certifique-se de não colocar nenhuma quebra de linha entre uma tag de fechamento ?&gt; e a tag &lt;!doctype&gt; do html. Versões antigas do IE entram em <a href="http://www.quirksmode.org/css/quirksmode.html">quirks mode (modo de compatibilidade)</a> se acharam algum espaço em branco, inclusive quebras de linha, antes da declaração do doctype. Esse não é um problema em novas versões do IE e nem em outros navegadores, mais avançados (Leia como: qualquer navegador além do IE).
                </ul>
            
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://stackoverflow.com/questions/200640/are-php-short-tags-acceptable-to-use">Stack Overflow: Are PHP short tags acceptable to use? (É aceitável usar tags curtas do PHP?)</a></li>
                </ul>
            </section>

            <section id="auto-loading">
                <h2>Autoloading de classes (carregamento automático de classes)</h2>
                <h3>Use a função <a href="http://php.net/manual/en/function.spl-autoload-register.php">spl_autoload_register()</a> para registrar sua função de autoloading.</h3>
                <p>O PHP tem várias maneiras de carregar automaticamente arquivos contendo classes que não tinham sido carregadas ainda. A maneira mais antiga é usar uma função global mágica chamada <a href="http://php.net/manual/en/function.autoload.php">__autoload()</a>. No entanto, você só pode ter uma função __autoload definida por vez, assim, se você estiver incluindo uma biblioteca que <i>também</i> usou a função __autoload(), acontecerá um conflito.</p>
                <p>O jeito correto de lidar com isso é dar a sua função de autoload um nome único, depois registrá-la com a função <a href="http://php.net/manual/en/function.spl-autoload-register.php">spl_autoload_register()</a>. Essa função permite que mais de uma função __autoload() seja definida, dessa forma você não conflita com nenhum outro código que tenha um __autoload() próprio.</p>
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Primeiro, defina sua função autoload.
                function MyAutoload($className){
                    include_once($className . '.php');
                }
        
                // Depois, registre-a no PHP.
                spl_autoload_register('MyAutoload');
        
                // Faça o teste!
                // Como não incluímos um arquivo com a definição do objeto MyClass, nosso autoloader irá localizar e incluir o arquivo MyClass.php.
                // Nesse exemplo, assuma que a classe MyClass está definida no arquivo MyClass.php.
                $var = new MyClass();
                ?&gt;</code>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/function.spl-autoload-register.php">PHP Manual: spl_autoload_register()</a></li>
                    <li><a href="http://stackoverflow.com/questions/791899/efficient-php-auto-loading-and-naming-strategies">Stack Overflow: Efficient PHP auto-loading and naming strategies (Estratégias eficientes de autoloading e nomenclatura no PHP
                    )</a></li>
                </ul>
            </section>
        
            <section id="quotes">
                <h2>Aspas duplas versus aspas simples olhando pela performance</h2>
                <h3>Não importa, de verdade.</h3>
                <p>Já deu muito o que falar a discussão se devemos definir strings com aspas simples (') ou aspas duplas ("). Strings com aspas simples não são interpretadas, assim, tudo que você colocar na string será mostrado. Strings com aspas duplas são interpretadas e variáveis PHP na string também são. Adicionalmente, caracteres de escape, como \n para quebra de linha e \t para tabulação, <i>não são</i> interpretados nas strings com aspas simples, mas <i>são</i> interpretados nas strings com aspas duplas.</p>
                <p>Como as strings com aspas duplas são avaliadas em tempo de execução, a teoria é que usar strings com aspas simples aumentaria a performance pois o PHP não teria que interpretar cada uma das strings. Mesmo com isso sendo verdade num certo ponto, para as aplicações médias do dia-a-dia a diferença é tão pequena que realmente não importa. Assim, para uma aplicação média, não importa o que você escolha. Para aplicações <em>extremamente</em> requisitadas, pode fazer um pouco de diferença. Tome sua decisão dependendo do que sua aplicação vai precisar, mas, não importa qual escolha, seja consistente.</p>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/language.types.string.php">PHP Manual: Strings</a></li>
                    <li><a href="http://phpbench.com/">The PHP Benchmark</a> (Role a página até Quote Types)</li>
                    <li><a href="http://stackoverflow.com/questions/482202/is-there-a-performance-benefit-single-quote-vs-double-quote-in-php">Stack Overflow: Is there a performance benefit to single quotes vs double quotes in PHP? (Existe um benefício de performance se usar aspas simples em vez de aspas duplas no PHP?)</a></li>
                </ul>
            </section>
            
            <section id="constants">
                <h2>define() versus const</h2>
                <h3>Use <a href="http://www.php.net/manual/en/function.define.php">define()</a> a menos que você tenha que se preocupar com legibilidade, constantes de classe ou micro-otimizações.</h3>
                <p>No PHP tradicionalmente constantes são definidas usando a função <a href="http://www.php.net/manual/en/function.define.php">define()</a>. Mas, em algum momento, o PHP passou a também poder declarar constantes através da palavra-chave <a href="http://php.net/manual/en/language.oop5.constants.php">const</a>. Qual delas você devia usar para quando for definir suas constantes?</p>
                <p>A resposta está nas pequenas diferenças entre as duas maneiras.</p>
                <ol>
                    <li>a função define() define constantes em tempo de execução, enquanto a palavra-chave const define constantes em tempo de compilação. Isso dá a const um ganho bem pequeno de velocidade, mas não o suficiente para se preocupar com isso, a menos que você esteja construindo um software de larga escala.</li>
                    <li>define() coloca as constantes no escopo global, embora você possa incluir namespaces ao nome de sua constante. Isso significa que você não pode usar define() para definir constantes de classe.</li>
                    <li>define() permite que você use expressões tanto no nome da constante quanto em seu valor, diferente de const, que não permite nenhum dos dois. Isso torna define() muito mais flexível.</li>
                    <li>define() pode ser chamada dentro de um bloco if(), enquanto const não.</li>
                </ol>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Vejamos como os dois métodos tratam namespaces
                namespace MiddleEarth\Creatures\Dwarves;
                const GIMLI_ID = 1;
                define('MiddleEarth\Creatures\Elves\LEGOLAS_ID', 2);
            
                echo(\MiddleEarth\Creatures\Dwarves\GIMLI_ID);  // 1
                echo(\MiddleEarth\Creatures\Elves\LEGOLAS_ID);  // 2; veja que usamos define(), mas o namespace ainda é reconhecido
            
                // Agora declaramos algumas constantes com bits deslocados representando modos de entrar em Mordor.
                define('TRANSPORT_METHOD_SNEAKING', 1 &lt;&lt; 0); // OK!
                const TRANSPORT_METHOD_WALKING = 1 &lt;&lt; 1; // Erro de compilação! const não pode usar expressões como valor
            
                // Em seguida, constantes condicionais.
                define('HOBBITS_FRODO_ID', 1);
            
                if($isGoingToMordor){
                    define('TRANSPORT_METHOD', TRANSPORT_METHOD_SNEAKING); // OK!
                    const PARTY_LEADER_ID = HOBBITS_FRODO_ID // Erro de compilação: const não pode ser usado em um bloco if
                }
            
                // Por fim, constantes de classe
                class OneRing{
                    const MELTING_POINT_CELSIUS = 1000000; // OK!
                    define('MELTING_POINT_ELVISH_DEGREES', 200); // Erro de compilação: não se pode usar define() dentro de uma classe
                }
                ?&gt;</code>
            
                <p>Como no fim define() é mais flexível, você deveria usá-lo para evitar dor de cabeça, a menos que você realmente precise de constantes de classe. Usar const geralmente resulta em código mais legível, mas perde-se na flexibilidade.</p>
            
                <p>Não importa qual você use, seja consistente!</p>
            
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://stackoverflow.com/questions/2447791/define-vs-const">Stack Overflow: define() vs const</a></li>
                    <li><a href="http://www.php.net/manual/en/language.constants.syntax.php">PHP Manual: Constantes</a></li>
                    <li><a href="http://stackoverflow.com/questions/1225082/define-vs-variable-in-php">Stack Overflow: define() vs variable (funcão define() versus variável)</a></li>
                </ul>
            </section>

            <section id="opcode-cache">
                <h2>Cache de opcode PHP</h2>
                <h3>Que sorte: o PHP já tem embutido o cache de opcode!</h3>
                <p>Em versões antigas do PHP, cada vez que um script era executado ele precisava ser compilado do início, mesmo se ele já tivesse sido compilado anteriormente. Os caches de opcode eram softwares adicionais que guardavam versões de código PHP previamente compilados, acelerando um pouco as coisas. Haviam muitas opções de cache que você poderia usar.</p>
                <p>Felizmente para nós, a versão do PHP que vem com o Ubuntu 14.04 <em>inclui um cache de opcode embutido</em> que vem ligado por padrão. Assim, você não precisa fazer nada!</p>
                <p>Para a posteridade, abaixo seguem algumas instruções de como usar um cache de opcode no Ubuntu 12.04, que não vem com um embutido.</p>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://www.php.net/manual/en/book.opcache.php">PHP Manual: Opcache</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)<br />
                    Use o <a href="http://php.net/manual/en/book.apc.php">APC</a> para cache de opcode.</h3>
                    <p>Existem muitos caches de opcode PHP disponíveis, em especial o <a href="http://sourceforge.net/projects/eaccelerator/">eaccelerator</a>, o <a href="http://xcache.lighttpd.net/">xcache</a> e o <a href="http://php.net/manual/en/book.apc.php">APC</a>. O APC é oficialmente apoiado pelo projeto PHP, é o mais ativo e o mais fácil de instalar. Ele também fornece opcionalmente um armazenamento de chave-valor persistente parecido com o <a href="http://memcached.org/">memcached</a>. Por essas razões, você deveria usá-lo.</p>
        
                    <h4>Instalação do APC</h4>
                    <p>Você pode instalar o APC no Ubuntu 12.04 executando este comando no seu terminal:</p>
                    <code class="terminal">sudo apt-get install php-apc</code>
                    <p>Nenhuma outra configuração é necessária.</p>
                    
                    <h4>Pegadinhas</h4>
                    <ul>
                        <li>Se você não estiver usando o <a href="#serving-php">PHP-FPM</a> (por exemplo, estiver usando o <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a> ou o <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a>), cada um dos processos PHP terá uma instância do APC própria, inclusive o armazenamento de chave-valor. Isso pode levar a problemas de sincronização no código da sua aplicação se você não tomar cuidado.</li>
                    </ul>
                    
                    <h4>Mais informações</h4>
                    <ul>
                        <li><a href="http://php.net/manual/en/book.apc.php">PHP Manual: APC</a></li>
                    </ul>
                </aside>
            </section>

            <section id="memcached">
                <h2>PHP e Memcached</h2>
                <h3>Se precisar de cache distribuído, use a biblioteca cliente do <a href="http://php.net/manual/en/book.memcached.php">Memcached</a>. Caso contrário, use o <a href="http://pecl.php.net/package/APCu">APCu</a>.</h3>
                <p>A caching system can often improve your app's performance.  <a href="http://memcached.org/">Memcached</a> is a popular choice and it works with many languages, including PHP.</p>
                <p>However, when it comes to accessing a Memcached server from a PHP script, you have two different and very stupidly named choices of client library: <a href="http://php.net/manual/en/book.memcache.php">Memcache</a> and <a href="http://php.net/manual/en/book.memcached.php">Memcached</a>.  They're different libraries with almost the same name, and both are used to access a Memcached instance.</p>
                <p>It turns out that the Memcache<u>d</u> library is the one that best implements the Memcached protocol.  It includes a few useful features that the Memcache library doesn't, and seems to be the one most actively developed.</p>
                <p>However if you don't need to access a Memcached instance from a series of distributed servers, then <a href="http://pecl.php.net/package/APCu">use APCu instead</a>.  APCu is supported by the PHP project and has much of the same functionality as Memcached.</p>
        
                <h4>Instalação da biblioteca cliente do Memcached</h4>
                <p>After you install the Memcached server, you need to install the Memcached client library.  Without the library, your PHP scripts won't be able to communicate with the Memcached server.</p>
                <p>You can install the Memcached client library on Ubuntu 14.04 by running this command in your terminal:</p>
                <code class="terminal">sudo apt-get install php5-memcached</code>
        
                <h4>Ou usar o APCu</h4>
                <p>Before Ubuntu 14.04, the APC project was both an opcode cache <em>and</em> a Memcached-like key-value store.  Since the version of PHP that ships with 14.04 <a href="#opcode-cache">now includes a built-in opcode cache</a>, APC was split into the APCu project, which is essentially APC's key-value storage functionality&mdash;AKA the "user cache", or the "u" in APCu&mdash;without the opcode-cache parts.</p>
                
                <h4>Instalação do APCu</h4>
                <p>You can install APCu on Ubuntu 14.04 by running this command in your terminal:</p>
                <code class="terminal">sudo apt-get install php5-apcu</code>
    
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Store some values in the APCu cache.  We can optionally pass a time-to-live, but in this example the values will live forever until they're garbage-collected by APCu.
                apc_store('username-1532', 'Frodo Baggins');
                apc_store('username-958', 'Aragorn');
                apc_store('username-6389', 'Gandalf');
    
                // After storing these values, any PHP script can access them, no matter when it's run!
                $value = apc_fetch('username-958', $success);
                if($success === true)
                    print($value); // Aragorn
        
                $value = apc_fetch('username-1', $success); // $success will be set to boolean false, because this key doesn't exist.
                if($success !== true) // Note the !==, this checks for true boolean false, not "falsey" values like 0 or empty string.
                    print('Key not found');
    
                apc_delete('username-958'); // This key will no longer be available.
                ?&gt;</code>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/book.memcached.php">PHP Manual: Memcached</a></li>
                    <li><a href="http://pecl.php.net/package/APCu">PECL: APCu</a></li>
                    <li><a href="http://stackoverflow.com/questions/1442411/using-memcache-vs-memcached-with-php">Stack Overflow: Using Memcache vs Memcached with PHP</a></li>
                    <li><a href="http://stackoverflow.com/questions/815041/memcached-vs-apc-which-one-should-i-choose">Stack Overflow: Memcached vs APC, which one should I choose?</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)<br />
                    Usar o <a href="http://php.net/manual/en/book.apc.php">APC</a> em vez do Memcached</h3>
                    <p>If you're using APC as both a key-value store and an opcode cache in Ubuntu 12.04, then the example above will also work&mdash;APC and APCu have an identical API.</p>
                    <p>See the <a href="#opcode-cache">section on opcode caching</a> for instructions on how to install APC on Ubuntu 12.04.</p>
                    
                    <h4>Mais informações</h4>
                    <ul>
                        <li><a href="http://php.net/manual/en/book.apc.php">PHP Manual: APC</a></li>
                    </ul>
                </aside>
            </section>

            <section id="regex">
                <h2>PHP e regex</h2>
                <h3>Use a família de funções <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (preg_*)</h3>
                <p>PHP has two different ways of using regular expressions: the <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (Perl-compatible, preg_*) functions and the <a href="http://php.net/manual/en/book.regex.php">POSIX</a> (POSIX extended, ereg_*) functions.</p>
                <p>Each family of functions uses a slightly different flavor of regular expression.  Luckily for us, the POSIX functions have been deprecated since PHP 5.3.0.  Because of this, you should never write new code using the POSIX functions.  Always use the PCRE functions, which are the preg_* functions.</p>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/book.pcre.php">PHP Manual: PCRE</a></li>
                    <li><a href="http://www.noupe.com/php/php-regular-expressions.html">Getting started with PHP regular expressions</a></li>
                </ul>
            </section>
        
            <section id="serving-php">
                <h2>Servindo o PHP num servidor web</h2>
                <h3>Use <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>.</h3>
                <p>There are several ways of configuring a web server to serve PHP.  The traditional (and terrible) way is to use Apache's <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a>.  Mod_php attaches PHP to Apache itself, but Apache does a very bad job of managing it.  You'll suffer from severe memory problems as soon as you get any kind of real traffic.</p>
                <p>Two new options soon became popular: <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a> and <a href="http://httpd.apache.org/mod_fcgid/">mod_fcgid</a>.  Both of these keep a limited number of PHP processes running, and Apache sends requests to these interfaces to handle PHP execution on its behalf.  Because these libraries limit how many PHP processes are alive, memory usage is greatly reduced without affecting performance.</p>
                <p>Some smart people created an implementation of fastcgi that was specially designed to work really well with PHP, and they called it <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>.  This was the standard solution for web servers since 12.04.</p>
                <p>In the years since Ubuntu 12.04, Apache introduced a new method of interacting with PHP-FPM: <a href="http://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a>.  Unfortunately, the version of Apache that ships with Ubuntu 14.04 has a few problems with this module, including not being able to use socket-based connections, issues with mod_rewrite, and issues with 404 and similar pages.  Because of these problems you should stick with the tried-and-true method of working with PHP-FPM that we used in Ubuntu 12.04.</p>
                <p>The following example is for Apache 2.4.7, but PHP-FPM also works for other web servers like Nginx.</p>
        
                <h4>Instalação do PHP-FPM e do Apache</h4>
                <p>You can install PHP-FPM and Apache on Ubuntu 14.04 by running these command in your terminal:</p>
                <code class="terminal multiline">
                    <span>sudo apt-get install apache2-mpm-event libapache2-mod-fastcgi php5-fpm</span>
                    <span>sudo a2enmod actions alias fastcgi</span>
                </code>
                <p>Note that we <em>must</em> use apache2-mpm-event (or apache2-mpm-worker), <em>not</em> apache2-mpm-prefork or apache2-mpm-threaded.</p>
                <p>Next, we'll configure our Apache virtualhost to route PHP requests to the PHP-FPM process.  Place the following in your Apache configuration file (in Ubuntu 14.04 the default one is /etc/apache2/sites-available/000-default.conf).</p>
                <code class="php">
                &lt;Directory /&gt;
                    Require all granted
                &lt;/Directory&gt;
                &lt;VirtualHost *:80&gt;
                    Action php5-fcgi /php5-fcgi
                    Alias /php5-fcgi /usr/lib/cgi-bin/php5-fcgi
                    FastCgiExternalServer /usr/lib/cgi-bin/php5-fcgi -socket /var/run/php5-fpm.socket -idle-timeout 120 -pass-header Authorization
                    &lt;FilesMatch "\.php$"&gt;
                        SetHandler  php5-fcgi
                    &lt;/FilesMatch&gt;
                &lt;/VirtualHost&gt;</code>
                <p>Finally, restart Apache and the FPM process:</p>
                <code class="terminal">sudo service apache2 restart && sudo service php5-fpm restart</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Using the <a href="http://httpd.apache.org/docs/2.4/mod/mod_mime.html#addhandler">AddHandler</a> directive instead of the <a href="http://httpd.apache.org/docs/2.4/mod/core.html#sethandler">SetHandler</a> directive can be a security risk.  AddHandler will execute PHP in files that have ".php" <em>anywhere in the file name</em>.  So if a user uploads evil.php.gif using your file upload form, you might be in for a nasty surprise.</li>
                </ul>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/install.fpm.php">PHP Manual: PHP-FPM</a></li>
                    <li><a href="http://php-fpm.org">PHP-FPM homepage</a></li>
                    <li><a href="https://alexcabal.com/installing-apache-mod_fastcgi-php-fpm-on-ubuntu-server-maverick/">Installing Apache + mod_fastcgi + PHP-FPM on Ubuntu Server Maverick</a></li>
                    <li><a href="http://www.joomlaperformance.com/articles/webcasts/why_mod_php_is_bad_for_performance_52_58.html">Why mod_php is bad for performance</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (Apache 2.2.22)</h3>
                    <p>The configuration for Ubuntu 12.04 is just as above, except don't include the &lt;Directory&gt; block in the configuration file.</p>
                    <p>The default site in Apache 2.2.22 is located at /etc/apache2/sites-available/default.</p>
                    <p>Apache 2.2.22 does not have a stable event MPM, so install apache2-mpm-worker instead of apache2-mpm-event.</p>
                </aside>
            </section>
        
            <section id="email">
                <h2>Envio de email</h2>
                <h3>Use <a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a>.</h3>
                <p><em>Tested with <a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> 5.2.7.</em></p>
                <p>PHP provides a <a href="http://php.net/manual/en/function.mail.php">mail()</a> function that looks enticingly simple and easy.  Unfortunately, like a lot of things in PHP, its simplicity is deceptive and using it at face value can lead to serious security problems.</p>
                <p>Email is a set of protocols with an even more tortured history than PHP.  Suffice it to say that there are so many gotchas in sending email that just being in the same room as PHP's mail() function should give you the shivers.</p>
                <p><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> is a popular and well-aged open-source library that provides an easy interface for sending mail securely.  It takes care of the gotchas for you so you can concentrate on more important things.</p>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Include the PHPMailer library
                require_once('phpmailer-5.2.7/PHPMailerAutoload.php');
        
                // Passing 'true' enables exceptions.  This is optional and defaults to false.
                $mailer = new PHPMailer(true);
        
                // Send a mail from Bilbo Baggins to Gandalf the Grey
        
                // Set up to, from, and the message body.  The body doesn't have to be HTML; check the PHPMailer documentation for details.
                $mailer->Sender = 'bbaggins@example.com';
                $mailer->AddReplyTo('bbaggins@example.com', 'Bilbo Baggins');
                $mailer->SetFrom('bbaggins@example.com', 'Bilbo Baggins');
                $mailer->AddAddress('gandalf@example.com');
                $mailer->Subject = 'The finest weed in the South Farthing';
                $mailer->MsgHTML('&lt;p&gt;You really must try it, Gandalf!&lt;/p&gt;&lt;p&gt;-Bilbo&lt;/p&gt;');
        
                // Set up our connection information.
                $mailer->IsSMTP();
                $mailer->SMTPAuth = true;
                $mailer->SMTPSecure = 'ssl';
                $mailer->Port = 465;
                $mailer->Host = 'my smtp host';
                $mailer->Username = 'my smtp username';
                $mailer->Password = 'my smtp password';
        
                // All done!
                $mailer->Send();
                ?&gt;</code>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer at Github</a></li>
                </ul> 
            </section>
        
            <section id="validating-emails">
                <h2>Validação de endereços de email</h2>
                <h3>Use a função <a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a>.</h3>
                <p>A common task your web app might need to do is to check if a user has entered a valid email address.  You'll no doubt find online a dizzying range of complex regular expressions that all claim to solve this problem, but the easiest way is to use PHP's built-in <a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a> function, which can validate email addresses.</p>
                
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                filter_var('sgamgee@example.com', FILTER_VALIDATE_EMAIL); // Returns "sgamgee@example.com". This is a valid email address.
                filter_var('sauron@mordor', FILTER_VALIDATE_EMAIL); // Returns boolean false! This is *not* a valid email address.
                ?&gt;</code>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/function.filter-var.php">PHP Manual: filter_var()</a></li>
                    <li><a href="http://php.net/manual/en/filter.filters.php">PHP Manual: Types of filters</a></li>
                </ul>
            </section>
        
            <section id="sanitizing-html">
                <h2>Sanitização de HTML, entrada e saída</h2>
                <h3>Use a função <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> para sanitização simples e a biblioteca <a href="http://htmlpurifier.org/">HTML Purifier</a> para sanitização complexa.</h3>
                <p><em>Tested with <a href="http://htmlpurifier.org/">HTML Purifier</a> 4.6.0.</em></p>
                <p>When displaying user input in any web application, it's essential to "sanitize" it first to remove any potentially dangerous HTML.  A malicious user can craft HTML that, if outputted directly by your web app, can be dangerous to the person viewing it.</p>
                <p>While it may be tempting to use regular expressions to sanitize HTML, <em>do not do this</em>.  HTML is a complex language and it's virtually guaranteed that any attempt you make at using regular expressions to sanitize HTML will fail.</p>
                <p>You might also find advice suggesting you use the <a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a> function.  While strip_tags() is technically safe to use, it's a "dumb" function in the sense that if the input is invalid HTML (say, is missing an ending tag), then strip_tags() might remove much more content than you expected.  As such it's not a great choice either, because non-technical users often use the &lt; and &gt; characters in communications.</p>
                <p>If you read the section on <a href="#validating-emails">validating email addresses</a>, you might also be considering using the <a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a> function.  However <a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">the filter_var() function has problems with line breaks</a>, and requires non-intuitive configuration to closely mirror the <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> function.  As such it's not a good choice either.</p>
        
                <h4>Sanitização para requisitos simples</h4>
                <p>If your web app only needs to completely escape (and thus render harmless, but not remove entirely) HTML, use PHP's built-in <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> function.  This function is much faster than HTML Purifier, because it doesn't perform any validation on the HTML&mdash;it just escapes everything.</p>
                <p>htmlentities() differs from its cousin <a href="http://php.net/manual/en/function.htmlspecialchars.php">htmlspecialchars()</a> in that it encodes <em>all</em> applicable HTML entities, not just a small subset.</p>
    
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
                $evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';
        
                // Use the ENT_QUOTES flag to make sure both single and double quotes are escaped.
                // Use the UTF-8 character encoding if you've stored the text as UTF-8 (as you should have).
                // See the UTF-8 section in this document for more details.
                $safeHtml = htmlentities($evilHtml, ENT_QUOTES, 'UTF-8'); // $safeHtml is now fully escaped HTML.  You can output $safeHtml to your users without fear!
                ?&gt;</code>
        
                <h4>Sanitização para requisitos complexos</h4>
                <p>For many web apps, simply escaping HTML isn't enough.  You probably want to entirely remove any HTML, or allow a small subset of HTML through.  To do this, use the <a href="http://htmlpurifier.org/">HTML Purifier</a> library.</p>
                <p>HTML Purifier is a well-tested but slow library.  That's why you should use <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> if your requirements aren't that complex, because it will be much, much faster.</p>
                <p>HTML Purifier has the advantage over <a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a> because it validates the HTML before sanitizing it.  That means if the user has inputted invalid HTML, HTML Purifier has a better chance of preserving the intended meaning of the HTML than strip_tags() does.  It's also highly customizable, allowing you to whitelist a subset of HTML to keep in the output.</p>
                <p>The downside is that it's quite slow, it requires some setup that might not be feasible in a shared hosting environment, and the documentation is often complex and unclear.  The following example is a basic configuration; check the <a href="http://htmlpurifier.org/docs">documentation</a> to read about the more advanced features HTML Purifier offers.</p>
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Include the HTML Purifier library
                require_once('htmlpurifier-4.6.0/HTMLPurifier.auto.php');
        
                // Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
                $evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';
        
                // Set up the HTML Purifier object with the default configuration.
                $purifier = new HTMLPurifier(HTMLPurifier_Config::createDefault());
        
                $safeHtml = $purifier->purify($evilHtml); // $safeHtml is now sanitized.  You can output $safeHtml to your users without fear!
                ?&gt;</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Using htmlentities() with the wrong character encoding can result in surprising output.  Always make sure that you specify a character encoding when calling the function, and that it matches the encoding of the string being sanitized.  See the <a href="#utf-8">UTF-8 section</a> for more details.</li>
                    <li>Always include the ENT_QUOTES and character encoding parameters when using htmlentities().  By default, htmlentities() doesn't encode single quotes.  What a dumb default!</li> 
                    <li>HTML Purifier is extremely slow for complex HTML.  Consider setting up a caching solution like <a href="#opcode-cache">APC</a> to store the sanitized result for later use.</li>
                </ul>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://htmlpurifier.org/comparison">Comparison between PHP HTML sanitizers</a></li>
                    <li><a href="http://stackoverflow.com/questions/3605629/php-prevent-xss-with-strip-tags">Stack Overflow: Prevent XSS with strip_tags()?</a></li>
                    <li><a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php">Stack Overflow: What's the best method for sanitizing user input with PHP?</a></li>
                    <li><a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">Stack Overflow: FILTER_SANITIZE_SPECIAL_CHARS problem with line breaks</a></li>
                </ul>
            </section>
        
            <section id="utf-8">
                <h2>PHP e UTF-8</h2>
                <h3>Não existe uma solução curta. Seja cuidadoso, detalhista e consistente.</h3>
                <p>UTF-8 in PHP sucks.  Sorry.</p>
                <p>Right now PHP does not support Unicode at a low level.  There are ways to ensure that UTF-8 strings are processed OK, but it's not easy, and it requires digging in to almost all levels of the web app, from HTML to SQL to PHP.  We'll aim for a brief, practical summary.</p>
                
                <h4>UTF-8 no nível do PHP</h4>
                <p>The basic <a href="http://php.net/manual/en/language.operators.string.php">string operations</a>, like concatenating two strings and assigning strings to variables, don't need anything special for UTF-8.  However most <a href="http://php.net/manual/en/ref.strings.php">string functions</a>, like <a href="http://php.net/manual/en/function.strpos.php">strpos()</a> and <a href="http://php.net/manual/en/function.strlen.php">strlen()</a>, <em>do</em> need special consideration.  These functions often have an mb_* counterpart: for example, <a href="http://php.net/manual/en/function.mb-strpos.php">mb_strpos()</a> and <a href="http://php.net/manual/en/function.mb-strlen.php">mb_strlen()</a>.  Together, these counterpart functions are called the <a href="http://php.net/manual/en/ref.mbstring.php">Multibyte String Functions</a>.  The multibyte string functions are specifically designed to operate on Unicode strings.</p>
                <p>You <em>must</em> use the mb_* functions whenever you operate on a Unicode string.  For example, if you use <a href="http://php.net/manual/en/function.substr.php">substr()</a> on a UTF-8 string, there's a good chance the result will include some garbled half-characters.  The correct function to use would be the multibyte counterpart, <a href="http://php.net/manual/en/function.mb-substr.php">mb_substr()</a>.</p>
                <p>The hard part is remembering to use the mb_* functions <em>at all times</em>.  If you forget even just once, your Unicode string has a chance of being garbled during further processing.</p>
                <p>Not all string functions have an mb_* counterpart.  If there isn't one for what you want to do, then you might be out of luck.</p>
                <p>Additionally, you should use the <a href="http://php.net/manual/en/function.mb-internal-encoding.php">mb_internal_encoding()</a> function at the top of every PHP script you write (or at the top of your global include script), and the <a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a> function right after it if your script is outputting to a browser.  Explicitly defining the encoding of your strings in every script will save you a lot of headaches down the road.</p>
                <p>Finally, many PHP functions that operate on strings have an optional parameter letting you specify the character encoding.  You should always explicitly indicate UTF-8 when given the option.  For example, <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> has an option for character encoding, and you should <em>always</em> specify UTF-8 if dealing with such strings.</p>
        
                <h4>UTF-8 no nível do MySQL</h4>
                <p>If your PHP script accesses MySQL, there's a chance your strings could be stored as non-UTF-8 strings in the database even if you follow all of the precautions above.</p>
                <p>To make sure your strings go from PHP to MySQL as UTF-8, make sure your database and tables are all set to the utf8mb4 character set and collation, and that you use the utf8mb4 character set in the PDO connection string.  For an example, see the section on <a href="#mysql">connecting to and querying a MySQL database</a>.  This is <em>critically important</em>.</p>
                <p>Note that you must use the `utf8mb4` character set for complete UTF-8 support, <em>not</em> the `utf8` character set!  See <a href="#utf8-further-reading">Mais informações</a> for why.</p>

                <h4>UTF-8 no nível do navegador</h4>
                <p>Use the <a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a> function to ensure that your PHP script outputs UTF-8 strings to your browser.  In your HTML, include the <a href="http://htmlpurifier.org/docs/enduser-utf8.html">charset &lt;meta&gt; tag</a> in your page's &lt;head&gt; tag.
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Tell PHP that we're using UTF-8 strings until the end of the script
                mb_internal_encoding('UTF-8');
        
                // Tell PHP that we'll be outputting UTF-8 to the browser
                mb_http_output('UTF-8');
        
                // Our UTF-8 test string
                $string = 'Êl síla erin lû e-govaned vîn.';
        
                // Transform the string in some way with a multibyte function
                // Note how we cut the string at a non-Ascii character for demonstration purposes
                $string = mb_substr($string, 0, 15);
        
                // Connect to a database to store the transformed string
                // See the PDO example in this document for more information
                // Note that we define the character set as utf8mb4 in the PDO connection string
                $link = new \PDO(   'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
                                    'your-username',
                                    'your-password',
                                    array(
                                        \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
                                        \PDO::ATTR_PERSISTENT => false
                                    )
                                );
                
                // Store our transformed string as UTF-8 in our database
                // Your DB and tables are in the utf8mb4 character set and collation, right?
                $handle = $link->prepare('insert into ElvishSentences (Id, Body) values (?, ?)');
                $handle->bindValue(1, 1, PDO::PARAM_INT);
                $handle->bindValue(2, $string);
                $handle->execute();
                
                // Retrieve the string we just stored to prove it was stored correctly
                $handle = $link->prepare('select * from ElvishSentences where Id = ?');
                $handle->bindValue(1, 1, PDO::PARAM_INT);
                $handle->execute();
                
                // Store the result into an object that we'll output later in our HTML
                $result = $handle->fetchAll(\PDO::FETCH_OBJ);
                ?&gt;&lt;!doctype html&gt;
                &lt;html&gt;
                    &lt;head&gt;
                        &lt;meta charset="UTF-8" /&gt;
                        &lt;title&gt;UTF-8 test page&lt;/title&gt;
                    &lt;/head&gt;
                    &lt;body&gt;
                        &lt;?php
                        foreach($result as $row){
                            print($row->Body);  // This should correctly output our transformed UTF-8 string to the browser
                        }
                        ?&gt;
                    &lt;/body&gt;
                &lt;/html&gt;</code>
        
                <h4 id="utf8-further-reading">Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/ref.mbstring.php">PHP Manual: Multibyte String Functions</a></li>
                    <li><a href="http://blog.loftdigital.com/blog/php-utf-8-cheatsheet">PHP UTF-8 Cheatsheet</a></li>
                    <li><a href="http://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible">Stack Overflow: What factors make PHP Unicode-incompatible?</a></li>
                    <li><a href="http://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings">Stack Overflow: Best practices in PHP and MySQL with international strings</a></li>
                    <li><a href="http://mathiasbynens.be/notes/mysql-utf8mb4">How to support full Unicode in MySQL databases</a></li>
                </ul>
            </section>
            
            <section id="working-with-dates-and-times">
                <h2>Trabalhando com datas e horários</h2>
                <h3>Use a classe <a href="http://www.php.net/manual/en/class.datetime.php">DateTime</a>.</h3>
                <p>In the bad old days of PHP we had to work with dates and times using a bewildering combination of <a href="http://www.php.net/manual/en/function.date.php">date()</a>, <a href="http://www.php.net/manual/en/function.gmdate.php">gmdate()</a>, <a href="http://www.php.net/manual/en/function.date-timezone-set.php">date_timezone_set()</a>, <a href="http://www.php.net/manual/en/function.strtotime.php">strtotime()</a>, and so on. Sadly you'll still find lots of tutorials online featuring these difficult and old-fashioned functions.</p>
                <p>Fortunately for us, the version of PHP we're talking about features the much friendlier <a href="http://www.php.net/manual/en/class.datetime.php">DateTime class</a>. This class encapsulates all the functionality <em>and more</em> of the old date functions in one easy-to-use class, with the bonus of making time zone conversions much simpler. Always use the DateTime class for creating, comparing, changing, and displaying dates in PHP.</p>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Construct a new UTC date.  Always specify UTC unless you really know what you're doing!
                $date = new DateTime('2011-05-04 05:00:00', new DateTimeZone('UTC'));

                // Add ten days to our initial date
                $date->add(new DateInterval('P10D'));

                echo($date->format('Y-m-d h:i:s')); // 2011-05-14 05:00:00

                // Sadly we don't have a Middle Earth timezone
                // Convert our UTC date to the PST (or PDT, depending) time zone
                $date->setTimezone(new DateTimeZone('America/Los_Angeles'));

                // Note that if you run this line yourself, it might differ by an hour depending on daylight savings
                echo($date->format('Y-m-d h:i:s')); // 2011-05-13 10:00:00

                $later = new DateTime('2012-05-20', new DateTimeZone('UTC'));

                // Compare two dates
                if($date &lt; $later)
                    echo('Yup, you can compare dates using these easy operators!');

                // Find the difference between two dates
                $difference = $date->diff($later);

                echo('The 2nd date is ' . $difference['days'] . ' later than 1st date.');
                ?&gt;
                </code>
                
                <h4>Pegadinhas</h4>
                <ul>
                    <li><p>If you don't specify a time zone, <a href="http://www.php.net/manual/en/datetime.construct.php">DateTime::__construct()</a> will set the resulting date's time zone to <em>the time zone of the computer you're running on</em>. This can lead to spectacular headaches later on. <strong>Always specify the UTC time zone when creating new dates unless you really know what you're doing.</strong></p></li>
                    <li><p>If you use a Unix timestamp in DateTime::__construct(), the time zone will always be set to UTC regardless of what you specify in the second argument.</p></li>
                    <li><p>Passing zeroed dates (e.g. &quot;0000-00-00&quot;, a value commonly produced by MySQL as the default value in a DateTime column) to DateTime::__construct() will result in a nonsensical date, not &quot;0000-00-00&quot;.</p></li>
                    <li><p>Using <a href="http://www.php.net/manual/en/datetime.gettimestamp.php">DateTime::getTimestamp()</a> on 32-bit systems will not represent dates past 2038. 64-bit systems are OK.</p></li>
                </ul>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><p><a href="http://www.php.net/manual/en/book.datetime.php">PHP Manual: The DateTime class</a></p></li>
                    <li><p><a href="http://stackoverflow.com/questions/5319710/accessing-dates-in-php-beyond-2038">Stack Overflow: Accessing dates beyond 2038</a></p></li>
                </ul>
            </section>
            
            <section id="checking-for-null">
                <h2>Verificando se um valor é null ou false</h2>
                <h3>Use o operador <a href="http://php.net/manual/en/language.operators.comparison.php">===</a> para verificar valores null e o boleano false.</h3>
                <p>PHP's loose typing system offers many different ways of checking a variable's value.  However it also presents a lot of problems.  Using <a href="http://php.net/manual/en/language.operators.comparison.php">==</a> to check if a value is null or false can return false positives if the value is actually an empty string or 0. <a href="http://php.net/manual/en/function.isset.php">isset()</a> checks whether a variable has a value, <em>not</em> whether that value is null or false, so it's not appropriate to use here.</p>
                <p>The <a href="http://php.net/manual/en/function.is-null.php">is_null()</a> function accurately checks if a value is null, and the <a href="http://php.net/manual/en/function.is-bool.php">is_bool()</a> function checks if it's a boolean value (like false), but there's an even better option: the <a href="http://php.net/manual/en/language.operators.comparison.php">===</a> operator.  === checks if the values are <em>identical</em>, which is not the same as <em>equivalent</em> in PHP's loosely-typed world.  It's also slightly faster than is_null() and is_bool(), and can be considered by some to be cleaner than using a function for comparison.</p>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                $x = 0;
                $y = null;
        
                // Is $x null?
                if($x == null)
                    print('Oops! $x is 0, not null!');
            
                // Is $y null?
                if(is_null($y))
                    print('Great, but could be faster.');
            
                if($y === null)
                    print('Perfect!');
        
                // Does the string abc contain the character a?
                if(strpos('abc', 'a'))
                    // GOTCHA!  strpos returns 0, indicating it wishes to return the position of the first character.
                    // But PHP interpretes 0 as false, so we never reach this print statement!
                    print('Found it!'); 
        
                //Solution: use !== (the opposite of ===) to see if strpos() returns 0, or boolean false.   
                if(strpos('abc', 'a') !== false)
                    print('Found it for real this time!');
                ?&gt;</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>When testing the return value of a function that can return either 0 or boolean false, like strpos(), always use === and !==, or you'll run in to problems.</li>
                </ul>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/language.operators.comparison.php">PHP Manual: Comparison operators</a></li>
                    <li><a href="http://stackoverflow.com/questions/8228837/is-nullx-vs-x-null-in-php">Stack Overflow: is_null() vs ===</a></li>
                </ul>
            </section>
        
            <section id="suggestions">
                <h2>Sugestões e correções</h2>
                <p>Thanks for reading!  If you haven't figured it out already, PHP is complex and filled with pitfalls.  Since I'm only human, there might be mistakes in this document.</p>
                <p>If you'd like to contribute to this document with suggestions or corrections, please contact me using the information in the <a href="#maintainers">last revised &amp; maintainers</a> section.</p>
            </section>
        </article>
        
        <footer>
            <p>
                <a href="/">PHP Melhores Práticas</a> por <a rel="author" href="https://alexcabal.com">Alex Cabal</a> e suas traduções são liberadas em <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.pt_BR">domínio público</a>.  <a href="https://alexcabal.com/why-i-release-things-into-the-public-domain/">Por que?</a>
            </p>
            <p>
                <a href="/">PHP Best Practices</a> by <a rel="author" href="https://alexcabal.com">Alex Cabal</a> and its translations are released into the <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">public domain</a>.  <a href="https://alexcabal.com/why-i-release-things-into-the-public-domain/">Why?</a>
            </p>
        </footer>
    </body>
</html>
