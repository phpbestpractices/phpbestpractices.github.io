<!doctype html>
<html lang="pt_BR">
    <head>
        <!-- EN-Revision: 37c7eea0a03a9129fb99e3e9355b05daa80d826e -->
        <title>PHP Melhores Práticas: um guia curto e prático para tarefas comuns e confusas no PHP</title>
        
        <meta charset="utf-8" />
        
        <link type="text/css" rel="stylesheet" href="css/core.css" media="screen" />
        <link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCore.css" media="screen" />
        <link type="text/css" rel="stylesheet" href="js/syntaxhighlighter-3.0.83/styles/shCoreDefault.css" media="screen" />
        
        <script type="text/javascript" src="js/jquery/jquery-1.7.2.min.js"></script>
        <script type="text/javascript" src="js/jquery/jquery.smooth-scroll-1.4.5.min.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shCore.js"></script>
        <script type="text/javascript" src="js/syntaxhighlighter-3.0.83/scripts/shBrushPhp.js"></script>
        
        <script type="text/javascript">
            $(document).ready(function(){
                $('code.php').attr('class', 'php brush: php');
                SyntaxHighlighter.config.tagName = 'code';
                SyntaxHighlighter.all()

                $('a').smoothScroll();

                $(window).scroll(function(){
                    UpdateToc();
                });

                // For some reason, without a timeout this doesn't set the right toc entry on load.
                // Timeout fixes this.  Must be a page layout timing issue.
                setTimeout(function(){ UpdateToc(); }, 500);
            });

            function UpdateToc(){
                var windowTop = $(window).scrollTop();
                var closestSectionId = '';
                var closestSectionTop = 0;

                $('section').each(function(){
                    if($(this).offset().top > closestSectionTop && $(this).offset().top <= windowTop + 40){
                        closestSectionTop =  $(this).offset().top;
                        closestSectionId = $(this).attr('id');
                    }
                });

                $('nav a').removeClass('highlighted');
                $('nav a[href$="' + closestSectionId + '"]').addClass("highlighted");

                if(windowTop > $('nav').offset().top)
                    $("nav").addClass("sticky");

                if(windowTop < 130)
                    $("nav").removeClass("sticky");
            }
        </script>
        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-35543520-1', 'phpbestpractices.org');
            ga('send', 'pageview');
        </script>
    </head>
    <body>
        <h1>PHP Melhores Práticas <span>Um guia curto e prático para tarefas comuns e confusas no PHP</span>
        <span class="translations"><a href="index.html">en</a> | <a href="index.pt_BR.html">pt_BR</a></span></h1>

        
        <nav>
            <ol>
                <li><a href="#maintainers">Última revisão &amp; mantenedores</a></li>
                <li><a href="#introduction">Introdução</a></li>
                <li><a href="#version">Que versão do PHP você está usando?</a></li>
                <li><a href="#passwords">Armazenando senhas</a></li>
                <li><a href="#mysql">PHP e MySQL</a></li>
                <li><a href="#php-tags">Tags PHP</a></li>
                <li><a href="#auto-loading">Auto-loading de classes</a></li>
                <li><a href="#quotes">Aspas duplas versus aspas simples</a></li>
                <li><a href="#constants">define() versus const</a></li>
                <li><a href="#opcode-cache">Cache de opcode PHP</a></li>
                <li><a href="#memcached">PHP e Memcached</a></li>
                <li><a href="#regex">PHP e regex</a></li>
                <li><a href="#serving-php">Servindo o PHP</a></li>
                <li><a href="#email">Envio de email</a></li>
                <li><a href="#validating-emails">Validação de endereços de email</a></li>
                <li><a href="#sanitizing-html">Sanitização de HTML</a></li>
                <li><a href="#utf-8">PHP e UTF-8</a></li>
                <li><a href="#working-with-dates-and-times">Trabalhando com datas e horários</a></li>
                <li><a href="#checking-for-null">Verificando valores null e false</a></li>
                <li><a href="#suggestions">Sugestões e correções</a></li>
            </ol>
        </nav>
        
        <article>
            <section id="maintainers">
                <h2>Última revisão &amp; mantenedores</h2>
                <p>O original em inglês deste documento foi revisado pela última vez em 3 de julho de 2014. Ele foi alterado pela última vez em 3 de julho de 2014.</p>
                <p>O original em inglês é mantido por <a href="https://alexcabal.com">Alex Cabal</a>.
                <p><a href="https://alexcabal.com/contact/">Converse com ele</a> se achar que ele possa te ajudar em algo, ou ainda se tiver sugestões ou correções para o documento original em inglês.</p>
            </section>
        
            <section id="introduction">
                <h2>Introdução</h2>
                <p>O PHP é uma linguagem complexa que, por anos, sofreu com reviravoltas, mudanças de direções, extensões forçadas e hacks. Ele é bastante inconsistente e, às vezes, até bugado. Cada versão é única com suas funcionalidades, estranhezas e peculiaridades, e fica difícil acompanhar que versão tem quais problemas. É fácil entender por que ele é tão odiado de vem em quando.</p>
                <p>Apesar disso, ele é a linguagem mais popular da web atualmente. Por causa da sua longa história, você encontrará um grande número de tutoriais de como fazer as coisas básicas, como criptografia de senhas e acesso a bancos de dados. O problema é que você tem uma chance bem grande de, em cinco tutoriais, encontrar cinco jeitos diferentes de se fazer cada uma dessas coisas. Qual deles é o jeito "certo"? Algum dos outros jeitos tem bugs escondidos ou armadilhas? É realmente bem difícil de saber e você ficará vagando eternamente na internet em busca da resposta perfeita.</p>
                <p>Essa também é uma das razões que fazem com que novos programadores PHP sejam frequentemente criticados por código feio, ultrapassado e inseguro. Mas eles não podem melhorar isso se o primeiro resultado de uma busca no Google for um artigo de quatro anos atrás ensinando uma técnica de cinco anos atrás!</p>
                <p>Este documento tenta mirar nesse problema. Ele é uma tentativa de compilar um conjunto de instruções básicas para o que podem ser consideradas melhores práticas para problemas e tarefas comuns no PHP. Se uma tarefa de baixo nível tem muitas soluções possíveis e confusas no PHP, ela deve estar aqui.</p>
        
                <h4>O que é</h4>
                <p>Este é um guia sugerindo a melhor direção a tomar quando você der de cara com uma das tarefas de <em>baixo nível</em>, que um programador PHP frequentemente deve encontrar, e que sejam pouco claras em virtude das muitas opções que o PHP oferece. Por exemplo: conectar com um banco de dados é uma tarefa frequente com uma gama enorme de soluções possíveis em PHP, nem todas sendo tão boas assim &mdash; por isso, ela está aqui neste documento.</p>
                <p>Esta é uma série de soluções pequenas e introdutórias. Os exemplos devem te entregar tudo que precisa para configurações básicas. Você deve fazer sua própria pesquisa para torná-las algo útil para você.</p>
                <p>Ele mostra o que consideramos o PHP mais moderno possível. No entanto, isso significa que se você estiver usando uma versão mais antiga do PHP, algumas das funcionalidades necessárias para se aproveitar das soluções daqui podem não estar disponíveis para você.</p>
                <p>Este é um documento vivo e faremos o melhor possível para mantê-lo atualizado com a constante evolução do PHP.</p>

                <h4>O que <em>não é</em></h4>
                <p>Este documento não é um tutorial de PHP. Você deve aprender as questões básicas de sintaxe da linguagem em algum outro lugar.</p>
                <p>Não é um guia para problemas comuns das aplicações web, como armazenamento de cookies, cache, estilo de código, documentação etc.</p>
                <p>Não é um guia de segurança. Apesar de abordar algumas questões relacionadas à segurança, é esperado que você faça sua própria pesquisa no tocante à segurança de suas aplicações PHP. Em particular, você deve revisar cuidadosamente qualquer solução proposta aqui antes de implementá-la, afinal, seu código é problema seu.</p>
                <p>Não é um defensor de nenhum estilo de código, padrão de desenvolvimento ou framework.</p>
                <p>Não é um defensor de nenhum modo para realização de tarefas de mais alto nível como gerenciamento de usuários, sistemas de acesso etc. Esse documento é estritamente focado em tarefas de <em>baixo nível</em> que podem ser, devido à longa história do PHP, confusas ou pouco claras.</p>
               <p>Não é a solução definitiva, nem mesmo a <em>única</em> solução. Alguns dos métodos descritos abaixo podem não ser os melhores para sua situação em particular e sempre existem vários jeitos diferentes de se chegar ao mesmo fim. Em particular, aplicações com alto tráfego podem se beneficiar de soluções mais complexas para alguns dos problemas citados.</p>
            </section>
        
        
            <section id="version">
                <h2>Que versão do PHP você está usando?</h2>
                <h3>PHP 5.5.9-1ubuntu4.2, instalado no Ubuntu 14.04 LTS.</h3>
                <p>O PHP é a tartaruga de 100 anos do mundo web. Seu casco está marcado por uma história rica, complicada e retorcida. Num ambiente de hospedagem compartilhada, a configuração dele pode restringir suas possibilidades.</p>
                <p>A fim de mantermos um pouco de sanidade, vamos focar apenas em uma versão do PHP. Em 30 de abril de 2014, essa versão é a <strong>PHP 5.5.9-1ubuntu4.2</strong>. Essa é a versão instalada usando o apt-get num servidor <strong>Ubuntu 14.04 LTS</strong>. Em outras palavras, esse é o padrão seguro que muitos utilizam.</p>
                <p>Talvez você descubra que algumas dessas soluções funcionam em versões diferentes, ou mais antigas, do PHP. Se isso acontecer, <em>cabe a você pesquisar as implicações dos possíveis bugs ou problemas de segurança dessas versões antigas</em>.</p>
                <aside>
                    <h3>Uma nota sobre o Ubuntu 12.04 LTS</h3>
                    <p>Muita coisa mudou no mundo PHP nos anos entre o Ubuntu 12.04 e o 14.04. Como o 12.04 ainda é muito comum, e como algumas das soluções abaixo mudaram de forma significativa no 14.04, incluirei soluções específicas para o 12.04 em uma caixa como esta aqui.</p>
                <p>A versão do PHP instalada no Ubuntu 12.04 usando o apt-get é a <b>PHP 5.3.10-1ubuntu3.6 with Suhosin-Patch</b>.</p>
                </aside>            
            </section>
        
            <section id="passwords">
                <h2>Armazenando senhas</h2>
                <h3>Use as funções embutidas de <a href="http://www.php.net/manual/en/book.password.php">password hashing</a> para fazer hash e comparar senhas.</h3>
                <p>Hashing is the standard way of protecting a user's password before it's stored in a database.  Many common hashing algorithms like md5 and even sha1 are unsafe for storing passwords, because <a href="http://arstechnica.com/security/2013/05/how-crackers-make-minced-meat-out-of-your-passwords/">hackers can easily crack passwords hashed using those algorithms</a>.</p>
                <p>PHP provides a built-in password hashing library that uses the bcrypt algorithm, currently considered the best algorithm for password hashing.</p>
                
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Hash the password.  $hashedPassword will be a 60-character string.
                $hashedPassword = password_hash('my super cool password', PASSWORD_DEFAULT);
        
                // You can now safely store the contents of $hashedPassword in your database!
        
                // Check if a user has provided the correct password by comparing what they typed with our hash
                password_verify('the wrong password', $hashedPassword); // false
        
                password_verify('my super cool password', $hashedPassword); // true
                ?&gt;</code>
                
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Many sources will recommend that you also "salt" your password before hashing it.  That's a great idea, and password_hash() <em>already salts your password for you</em>.  That means that you don't have to salt it yourself.</li>
                </ul>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://blogs.msdn.com/b/lixiong/archive/2011/12/25/md5-sha1-salt-and-bcrypt.aspx">Why hashing passwords with md5 or sha is unsafe</a></li>
                    <li><a href="http://codahale.com/how-to-safely-store-a-password/">How to safely store a password</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)<br />
                    Use a biblioteca <a href="http://www.openwall.com/phpass/">phpass</a> para fazer hash e comparar senhas.</h3>
                    <p><em>Tested with <a href="http://www.openwall.com/phpass/">phpass</a> 0.3.</em></p>
                    <p>The built-in PHP password hashing library isn't available in the version of PHP installed in 12.04.  Instead, use the open-source <a href="http://www.openwall.com/phpass/">phpass</a> library, which provides the same bcrypt-based functionality in an easy-to-use class.</p>
        
                    <h4>Exemplo</h4>
                    <code class="php">
                    &lt;?php
                    // Include the phpass library
                    require_once('phpass-0.3/PasswordHash.php');
        
                    // Initialize the hasher without portable hashes (this is more secure)
                    $hasher = new PasswordHash(8, false);
        
                    // Hash the password.  $hashedPassword will be a 60-character string.
                    $hashedPassword = $hasher->HashPassword('my super cool password');
        
                    // You can now safely store the contents of $hashedPassword in your database!
        
                    // Check if a user has provided the correct password by comparing what they typed with our hash
                    $hasher->CheckPassword('the wrong password', $hashedPassword); // false
        
                    $hasher->CheckPassword('my super cool password', $hashedPassword); // true
                    ?&gt;</code>
                
                    <h4>Mais informações</h4>
                    <ul>
                        <li><a href="http://www.openwall.com/phpass/">phpass</a></li>
                    </ul>
                    
                    <h4>Pegadinhas</h4>
                    <ul>
                        <li>Just like password_hash() in new versions of PHP, phpass automatically salts your password for you.</li>
                    </ul>
                </aside>
            </section>
            
            <section id="mysql">
                <h2>Conectando e consultando um banco de dados MySQL</h2>
                <h3>Use a <a href="http://php.net/manual/en/book.pdo.php">PDO</a> e sua funcionalidade de prepared statement.</h3>
                <p>There are many ways to connect to a MySQL database in PHP.  <a href="http://php.net/manual/en/book.pdo.php">PDO</a> (PHP Data Objects) is the newest and most robust of them.  PDO has a consistent interface across many different types of database, uses an object-oriented approach, and supports more features offered by newer databases.</p>
                <p>You should use PDO's prepared statement functions to help prevent SQL injection attacks.  Using the <a href="http://php.net/manual/en/pdostatement.bindvalue.php">bindValue()</a> function ensures that your SQL is safe from first-order SQL injection attacks.  (This isn't 100% foolproof though, see <a href="#pdo-further-reading">Mais informações</a> for more details.)  In the past, this had to be achieved with some arcane combination of "magic quote" functions.  PDO makes all that gunk unnecessary.</p>
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                try{
                    // Create a new connection.
                    // You'll probably want to replace hostname with localhost in the first parameter.
                    // Note how we declare the charset to be utf8mb4.  This alerts the connection that we'll be passing UTF-8 data.  This may not be required depending on your configuration, but it'll save you headaches down the road if you're trying to store Unicode strings in your database.  See "Pegadinhas".
                    // The PDO options we pass do the following:
                    // \PDO::ATTR_ERRMODE enables exceptions for errors.  This is optional but can be handy.
                    // \PDO::ATTR_PERSISTENT disables persistent connections, which can cause concurrency issues in certain cases.  See "Pegadinhas".
                    $link = new \PDO(   'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4', 
                                        'your-username', 
                                        'your-password', 
                                        array(
                                            \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION, 
                                            \PDO::ATTR_PERSISTENT => false
                                        )
                                    );

                    $handle = $link->prepare('select Username from Users where UserId = ? or Username = ? limit ?');

                    // PHP bug: if you don't specify PDO::PARAM_INT, PDO may enclose the argument in quotes.  This can mess up some MySQL queries that don't expect integers to be quoted.
                    // See: https://bugs.php.net/bug.php?id=44639
                    // If you're not sure whether the value you're passing is an integer, use the is_int() function.
                    $handle->bindValue(1, 100, PDO::PARAM_INT);
                    $handle->bindValue(2, 'Bilbo Baggins');
                    $handle->bindValue(3, 5, PDO::PARAM_INT);

                    $handle->execute();

                    // Using the fetchAll() method might be too resource-heavy if you're selecting a truly massive amount of rows.
                    // If that's the case, you can use the fetch() method and loop through each result row one by one.
                    // You can also return arrays and other things instead of objects.  See the PDO documentation for details.
                    $result = $handle->fetchAll(\PDO::FETCH_OBJ);

                    foreach($result as $row){
                        print($row->Username);
                    }
                }
                catch(\PDOException $ex){
                    print($ex->getMessage());
                }
                ?&gt;</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Not passing the PDO::PARAM_INT parameter when binding integer variables can sometimes cause PDO to quote them.  This can screw up certain MySQL queries.  See <a href="https://bugs.php.net/bug.php?id=44639">this bug report</a>.</li>
                    <li>Not having set the character set to utf8mb4 in the connection string might cause Unicode data to be stored incorrectly in your database, depending on your configuration.</li>
                    <li>Even if you declare your character set to be utf8mb4, make sure that your actual database tables are in the utf8mb4 character set.  For why we use utf8mb4 instead of just utf8, check the <a href="#utf-8">PHP e UTF-8</a> section.</li>
                    <li>Enabling persistent connections can possibly lead to weird concurrency-related issues.  This isn't a PHP problem, it's an app-level problem.  Persistent connections are safe to use as long as you consider the consequences.  See <a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo">this Stack Overflow question</a>.</li>
                    <li>You can execute more than one SQL statement in a single execute() call.  Just separate the statements with semicolons.  <b>Ubuntu 12.04 (PHP &lt;= 5.3.10):</b> If doing this, beware of <a href="https://bugs.php.net/bug.php?id=61207">this bug</a>, which isn't fixed in the version of PHP shipped with Ubuntu 12.04.</li>
                </ul>
        
                <h4 id="pdo-further-reading">Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/book.pdo.php">PHP Manual: PDO</a></li>
                    <li><a href="http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/">Why you should be using PHP's PDO for database access</a></li>
                    <li><a href="http://stackoverflow.com/questions/1402017/php-pdo-vs-normal-mysql-connect">Stack Overflow: PHP PDO vs normal mysql_connect</a></li>
                    <li><a href="http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection">Stack Overflow: Are PDO prepared statements sufficient to prevent SQL injection?</a></li>
                    <li><a href="https://stackoverflow.com/questions/1650591/whether-to-use-set-names">Stack Overflow: Whether to use "SET NAMES"</a></li>
                </ul>
            </section>

            <section id="php-tags">
                <h2>Tags PHP</h2>
                <h3>Use &lt;?php ?&gt;.</h3>
                <p>Existe um punhado de maneiras diferentes de delimitar blocos de código PHP: &lt;?php ?&gt;, &lt;?= ?&gt;, &lt;? ?&gt;e &lt;% %&gt;. Mesmo que as mais curtas possam ser mais convenientes para digitar, a único que é garantido que funciona em todos os servidores PHP é a &lt;?php ?&gt;. Se você ao menos pensa em fazer deploy da sua aplicação PHP em um servidor cuja configuração você não pode controlar, você deve sempre usar a &lt;?php ?&gt;.</p>
                <p>Se você estiver programando para você mesmo e tiver controle da configuração do PHP que irá usar, você pode achar que as tags mais curtas sejam mais convenientes. Mas lembre-se que &lt;? ?&gt; pode conflitar com declarações XML e &lt;% %&gt; é na verdade a tag do ASP.</p>
                <p>Não importa o que escolher, certifique-se de ser consistente!</p>
            
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Quando incluir uma tag de fechamento ?&gt; em um arquivo de PHP puro (por exemplo, em um arquivo que contém apenas uma definição de classe), <em>certifique-se de não colocar nenhuma quebra de linha depois dela</em>. Apesar do parser do PHP "engolir" de forma segura um caractere único de quebra de linha depois de uma tag de fechamento, outras quebras de linha adicionais podem ser mostradas no navegador e bagunçar as coisas se você for enviar algum cabeçalho HTTP em seguida.</li>
                    <li>Quando escrever uma aplicação web para versões antigas do IE, certifique-se de não colocar nenhuma quebra de linha entre uma tag de fechamento ?&gt; e a tag &lt;!doctype&gt; do html. Versões antigas do IE entram em <a href="http://www.quirksmode.org/css/quirksmode.html">quirks mode (modo de compatibilidade)</a> se acharam algum espaço em branco, inclusive quebras de linha, antes da declaração do doctype. Esse não é um problema em novas versões do IE e nem em outros navegadores, mais avançados (Leia como: qualquer navegador além do IE).
                </ul>
            
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://stackoverflow.com/questions/200640/are-php-short-tags-acceptable-to-use">Stack Overflow: Are PHP short tags acceptable to use? (É aceitável usar tags curtas do PHP?)</a></li>
                </ul>
            </section>

            <section id="auto-loading">
                <h2>Auto-loading de classes</h2>
                <h3>Use a função <a href="http://php.net/manual/en/function.spl-autoload-register.php">spl_autoload_register()</a> para registrar sua função auto-load.</h3>
                <p>PHP provides several ways to auto-load files containing classes that haven't yet been loaded.  The older way is to use a magic global function called <a href="http://php.net/manual/en/function.autoload.php">__autoload()</a>.  However you can only have one __autoload() function defined at once, so if you're including a library that <i>also</i> uses the __autoload() function, then you'll have a conflict.</p>
                <p>The correct way to handle this is to name your autoload function something unique, then register it with the <a href="http://php.net/manual/en/function.spl-autoload-register.php">spl_autoload_register()</a> function.  This function allows more than one __autoload() function to be defined, so you won't step on any other code's own __autoload() function.</p>
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // First, define your auto-load function.
                function MyAutoload($className){
                    include_once($className . '.php');
                }
        
                // Next, register it with PHP.
                spl_autoload_register('MyAutoload');
        
                // Try it out!
                // Since we haven't included a file defining the MyClass object, our auto-loader will kick in and include MyClass.php.
                // For this example, assume the MyClass class is defined in the MyClass.php file.
                $var = new MyClass();
                ?&gt;</code>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/function.spl-autoload-register.php">PHP Manual: spl_autoload_register()</a></li>
                    <li><a href="http://stackoverflow.com/questions/791899/efficient-php-auto-loading-and-naming-strategies">Stack Overflow: Efficient PHP auto-loading and naming strategies</a></li>
                </ul>
            </section>
        
            <section id="quotes">
                <h2>Aspas duplas versus aspas simples olhando pela performance</h2>
                <h3>Não importa, de verdade.</h3>
                <p>A lot of ink has been spilled about whether to define strings with single quotes (') or double quotes (").  Single-quoted strings aren't parsed, so whatever you've put in the string, that's what will show up.  Double-quoted strings are parsed and any PHP variables in the string are evaluated.  Additionally, escaped characters like \n for newline and \t for tab <i>are not</i> evaluated in single-quoted strings, but <i>are</i> evaluated in double-quoted strings.</p>
                <p>Because double-quoted strings are evaluated at run time, the theory is that using single-quoted strings will improve performance because PHP won't have to evaluate every single string.  While this might be true on a certain scale, for the average real-life application the difference is so small that it doesn't really matter.  So for an average app, it doesn't matter what you choose.  For <em>extremely</em> high-load apps, it might matter a little.  Make a choice depending on what your app needs, but whatever you choose, be consistent.</p>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/language.types.string.php">PHP Manual: Strings</a></li>
                    <li><a href="http://phpbench.com/">The PHP Benchmark</a> (Scroll down to Quote Types)</li>
                    <li><a href="http://stackoverflow.com/questions/482202/is-there-a-performance-benefit-single-quote-vs-double-quote-in-php">Stack Overflow: Is there a performance benefit to single quotes vs double quotes in PHP?</a></li>
                </ul>
            </section>
            
            <section id="constants">
                <h2>define() versus const</h2>
                <h3>Use <a href="http://www.php.net/manual/en/function.define.php">define()</a> a menos que você tenha que se preocupar com legibilidade, constantes de classe ou micro-otimizações.</h3>
                <p>Traditionally in PHP you would define constants using the <a href="http://www.php.net/manual/en/function.define.php">define()</a> function.  But at some point PHP gained the ability to also declare constants with the <a href="http://php.net/manual/en/language.oop5.constants.php">const</a> keyword.  Which one should you use when defining your constants?</p>
                <p>The answer lies in the little differences between the two methods.</p>
                <ol>
                    <li>define() defines constants at run time, while const defines constants at compile time.  This gives const a very slight speed edge, but not one worth worrying about unless you're building large-scale software.</li>
                    <li>define() puts constants in the global scope, although you can include namespaces in your constant name.  That means you can't use define() to define class constants.</li>
                    <li>define() lets you use expressions both in the constant name and in the constant value, unlike const which allows neither.  This makes define() much more flexible.</li>
                    <li>define() can be called within an if() block, while const cannot.</li>
                </ol>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Let's see how the two methods treat namespaces
                namespace MiddleEarth\Creatures\Dwarves;
                const GIMLI_ID = 1;
                define('MiddleEarth\Creatures\Elves\LEGOLAS_ID', 2);
            
                echo(\MiddleEarth\Creatures\Dwarves\GIMLI_ID);  // 1
                echo(\MiddleEarth\Creatures\Elves\LEGOLAS_ID);  // 2; note that we used define(), but the namespace is still recognized
            
                // Now let's declare some bit-shifted constants representing ways to enter Mordor.
                define('TRANSPORT_METHOD_SNEAKING', 1 &lt;&lt; 0); // OK!
                const TRANSPORT_METHOD_WALKING = 1 &lt;&lt; 1; // Compile error! const can't use expressions as values
            
                // Next, conditional constants.
                define('HOBBITS_FRODO_ID', 1);
            
                if($isGoingToMordor){
                    define('TRANSPORT_METHOD', TRANSPORT_METHOD_SNEAKING); // OK!
                    const PARTY_LEADER_ID = HOBBITS_FRODO_ID // Compile error: const can't be used in an if block
                }
            
                // Finally, class constants
                class OneRing{
                    const MELTING_POINT_CELSIUS = 1000000; // OK!
                    define('MELTING_POINT_ELVISH_DEGREES', 200); // Compile error: can't use define() within a class
                }
                ?&gt;</code>
            
                <p>Because define() is ultimately more flexible, it's the one you should use to avoid headaches unless you specifically require class constants.  Using const generally results in more readable code, but at the expense of flexibility.</p>
            
                <p>Whichever one you use, be consistent!</p>
            
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://stackoverflow.com/questions/2447791/define-vs-const">Stack Overflow: define() vs const</a></li>
                    <li><a href="http://www.php.net/manual/en/language.constants.syntax.php">PHP Manual: Constants</a></li>
                    <li><a href="http://stackoverflow.com/questions/1225082/define-vs-variable-in-php">Stack Overflow: define() vs variable</a></li>
                </ul>
            </section>

            <section id="opcode-cache">
                <h2>Cache de opcode PHP</h2>
                <h3>Que sorte: o PHP já tem embutido o cache de opcode!</h3>
                <p>In older versions of PHP, every time a script was executed it would have to be compiled from scratch, even if it had been compiled before.  Opcode caches were additional software that saved previously compiled versions of PHP, speeding things up a bit.  There were various flavors of caches you could choose from.</p>
                <p>Lucky for us, the version of PHP that ships with Ubuntu 14.04 <em>includes a built-in opcode cache</em> that's turned on by default.  So there's nothing for you to do!</p>
                <p>For posterity, below are instructions for using an opcode cache in Ubuntu 12.04, which doesn't include its own.</p>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://www.php.net/manual/en/book.opcache.php">PHP Manual: Opcache</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)<br />
                    Use o <a href="http://php.net/manual/en/book.apc.php">APC</a> como para cache de opcode.</h3>
                    <p>There are several PHP opcode caches available, notably <a href="http://sourceforge.net/projects/eaccelerator/">eaccelerator</a>, <a href="http://xcache.lighttpd.net/">xcache</a>, and <a href="http://php.net/manual/en/book.apc.php">APC</a>.  APC is officially supported by the PHP project, is the most active, and is the easiest to install.  It also provides an optional <a href="http://memcached.org/">memcached</a>-like persistent key-value store.  For these reasons, it's the one you should be using.</p>
        
                    <h4>Instalação do APC</h4>
                    <p>You can install APC on Ubuntu 12.04 by running this command in your terminal:</p>
                    <code class="terminal">sudo apt-get install php-apc</code>
                    <p>No further configuration is necessary.</p>
                    
                    <h4>Pegadinhas</h4>
                    <ul>
                        <li>If you're not using <a href="#serving-php">PHP-FPM</a> (for example you're using <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a> or <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a>), each PHP process will have its unique APC instance, including key-value store.  This can lead to synchronization problems in your app code if you're not careful.</li>
                    </ul>
                    
                    <h4>Mais informações</h4>
                    <ul>
                        <li><a href="http://php.net/manual/en/book.apc.php">PHP Manual: APC</a></li>
                    </ul>
                </aside>
            </section>

            <section id="memcached">
                <h2>PHP e Memcached</h2>
                <h3>Se precisar de cache distribuído, use a biblioteca cliente do <a href="http://php.net/manual/en/book.memcached.php">Memcached</a>. Caso contrário, use o <a href="http://pecl.php.net/package/APCu">APCu</a>.</h3>
                <p>A caching system can often improve your app's performance.  <a href="http://memcached.org/">Memcached</a> is a popular choice and it works with many languages, including PHP.</p>
                <p>However, when it comes to accessing a Memcached server from a PHP script, you have two different and very stupidly named choices of client library: <a href="http://php.net/manual/en/book.memcache.php">Memcache</a> and <a href="http://php.net/manual/en/book.memcached.php">Memcached</a>.  They're different libraries with almost the same name, and both are used to access a Memcached instance.</p>
                <p>It turns out that the Memcache<u>d</u> library is the one that best implements the Memcached protocol.  It includes a few useful features that the Memcache library doesn't, and seems to be the one most actively developed.</p>
                <p>However if you don't need to access a Memcached instance from a series of distributed servers, then <a href="http://pecl.php.net/package/APCu">use APCu instead</a>.  APCu is supported by the PHP project and has much of the same functionality as Memcached.</p>
        
                <h4>Instalação da biblioteca cliente do Memcached</h4>
                <p>After you install the Memcached server, you need to install the Memcached client library.  Without the library, your PHP scripts won't be able to communicate with the Memcached server.</p>
                <p>You can install the Memcached client library on Ubuntu 14.04 by running this command in your terminal:</p>
                <code class="terminal">sudo apt-get install php5-memcached</code>
        
                <h4>Ou usar o APCu</h4>
                <p>Before Ubuntu 14.04, the APC project was both an opcode cache <em>and</em> a Memcached-like key-value store.  Since the version of PHP that ships with 14.04 <a href="#opcode-cache">now includes a built-in opcode cache</a>, APC was split into the APCu project, which is essentially APC's key-value storage functionality&mdash;AKA the "user cache", or the "u" in APCu&mdash;without the opcode-cache parts.</p>
                
                <h4>Instalação do APCu</h4>
                <p>You can install APCu on Ubuntu 14.04 by running this command in your terminal:</p>
                <code class="terminal">sudo apt-get install php5-apcu</code>
    
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Store some values in the APCu cache.  We can optionally pass a time-to-live, but in this example the values will live forever until they're garbage-collected by APCu.
                apc_store('username-1532', 'Frodo Baggins');
                apc_store('username-958', 'Aragorn');
                apc_store('username-6389', 'Gandalf');
    
                // After storing these values, any PHP script can access them, no matter when it's run!
                $value = apc_fetch('username-958', $success);
                if($success === true)
                    print($value); // Aragorn
        
                $value = apc_fetch('username-1', $success); // $success will be set to boolean false, because this key doesn't exist.
                if($success !== true) // Note the !==, this checks for true boolean false, not "falsey" values like 0 or empty string.
                    print('Key not found');
    
                apc_delete('username-958'); // This key will no longer be available.
                ?&gt;</code>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/book.memcached.php">PHP Manual: Memcached</a></li>
                    <li><a href="http://pecl.php.net/package/APCu">PECL: APCu</a></li>
                    <li><a href="http://stackoverflow.com/questions/1442411/using-memcache-vs-memcached-with-php">Stack Overflow: Using Memcache vs Memcached with PHP</a></li>
                    <li><a href="http://stackoverflow.com/questions/815041/memcached-vs-apc-which-one-should-i-choose">Stack Overflow: Memcached vs APC, which one should I choose?</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (PHP &lt;= 5.3.10)<br />
                    Usar o <a href="http://php.net/manual/en/book.apc.php">APC</a> em vez do Memcached</h3>
                    <p>If you're using APC as both a key-value store and an opcode cache in Ubuntu 12.04, then the example above will also work&mdash;APC and APCu have an identical API.</p>
                    <p>See the <a href="#opcode-cache">section on opcode caching</a> for instructions on how to install APC on Ubuntu 12.04.</p>
                    
                    <h4>Mais informações</h4>
                    <ul>
                        <li><a href="http://php.net/manual/en/book.apc.php">PHP Manual: APC</a></li>
                    </ul>
                </aside>
            </section>

            <section id="regex">
                <h2>PHP e regex</h2>
                <h3>Use a família de funções <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (preg_*)</h3>
                <p>PHP has two different ways of using regular expressions: the <a href="http://php.net/manual/en/book.pcre.php">PCRE</a> (Perl-compatible, preg_*) functions and the <a href="http://php.net/manual/en/book.regex.php">POSIX</a> (POSIX extended, ereg_*) functions.</p>
                <p>Each family of functions uses a slightly different flavor of regular expression.  Luckily for us, the POSIX functions have been deprecated since PHP 5.3.0.  Because of this, you should never write new code using the POSIX functions.  Always use the PCRE functions, which are the preg_* functions.</p>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/book.pcre.php">PHP Manual: PCRE</a></li>
                    <li><a href="http://www.noupe.com/php/php-regular-expressions.html">Getting started with PHP regular expressions</a></li>
                </ul>
            </section>
        
            <section id="serving-php">
                <h2>Servindo o PHP num servidor web</h2>
                <h3>Use <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>.</h3>
                <p>There are several ways of configuring a web server to serve PHP.  The traditional (and terrible) way is to use Apache's <a href="http://stackoverflow.com/questions/2712825/what-is-mod-php">mod_php</a>.  Mod_php attaches PHP to Apache itself, but Apache does a very bad job of managing it.  You'll suffer from severe memory problems as soon as you get any kind of real traffic.</p>
                <p>Two new options soon became popular: <a href="http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html">mod_fastcgi</a> and <a href="http://httpd.apache.org/mod_fcgid/">mod_fcgid</a>.  Both of these keep a limited number of PHP processes running, and Apache sends requests to these interfaces to handle PHP execution on its behalf.  Because these libraries limit how many PHP processes are alive, memory usage is greatly reduced without affecting performance.</p>
                <p>Some smart people created an implementation of fastcgi that was specially designed to work really well with PHP, and they called it <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>.  This was the standard solution for web servers since 12.04.</p>
                <p>In the years since Ubuntu 12.04, Apache introduced a new method of interacting with PHP-FPM: <a href="http://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html">mod_proxy_fcgi</a>.  Unfortunately, the version of Apache that ships with Ubuntu 14.04 has a few problems with this module, including not being able to use socket-based connections, issues with mod_rewrite, and issues with 404 and similar pages.  Because of these problems you should stick with the tried-and-true method of working with PHP-FPM that we used in Ubuntu 12.04.</p>
                <p>The following example is for Apache 2.4.7, but PHP-FPM also works for other web servers like Nginx.</p>
        
                <h4>Instalação do PHP-FPM e do Apache</h4>
                <p>You can install PHP-FPM and Apache on Ubuntu 14.04 by running these command in your terminal:</p>
                <code class="terminal multiline">
                    <span>sudo apt-get install apache2-mpm-event libapache2-mod-fastcgi php5-fpm</span>
                    <span>sudo a2enmod actions alias fastcgi</span>
                </code>
                <p>Note that we <em>must</em> use apache2-mpm-event (or apache2-mpm-worker), <em>not</em> apache2-mpm-prefork or apache2-mpm-threaded.</p>
                <p>Next, we'll configure our Apache virtualhost to route PHP requests to the PHP-FPM process.  Place the following in your Apache configuration file (in Ubuntu 14.04 the default one is /etc/apache2/sites-available/000-default.conf).</p>
                <code class="php">
                &lt;Directory /&gt;
                    Require all granted
                &lt;/Directory&gt;
                &lt;VirtualHost *:80&gt;
                    Action php5-fcgi /php5-fcgi
                    Alias /php5-fcgi /usr/lib/cgi-bin/php5-fcgi
                    FastCgiExternalServer /usr/lib/cgi-bin/php5-fcgi -socket /var/run/php5-fpm.socket -idle-timeout 120 -pass-header Authorization
                    &lt;FilesMatch "\.php$"&gt;
                        SetHandler  php5-fcgi
                    &lt;/FilesMatch&gt;
                &lt;/VirtualHost&gt;</code>
                <p>Finally, restart Apache and the FPM process:</p>
                <code class="terminal">sudo service apache2 restart && sudo service php5-fpm restart</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Using the <a href="http://httpd.apache.org/docs/2.4/mod/mod_mime.html#addhandler">AddHandler</a> directive instead of the <a href="http://httpd.apache.org/docs/2.4/mod/core.html#sethandler">SetHandler</a> directive can be a security risk.  AddHandler will execute PHP in files that have ".php" <em>anywhere in the file name</em>.  So if a user uploads evil.php.gif using your file upload form, you might be in for a nasty surprise.</li>
                </ul>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/install.fpm.php">PHP Manual: PHP-FPM</a></li>
                    <li><a href="http://php-fpm.org">PHP-FPM homepage</a></li>
                    <li><a href="https://alexcabal.com/installing-apache-mod_fastcgi-php-fpm-on-ubuntu-server-maverick/">Installing Apache + mod_fastcgi + PHP-FPM on Ubuntu Server Maverick</a></li>
                    <li><a href="http://www.joomlaperformance.com/articles/webcasts/why_mod_php_is_bad_for_performance_52_58.html">Why mod_php is bad for performance</a></li>
                </ul>
                
                <aside>
                    <h3>Ubuntu 12.04 (Apache 2.2.22)</h3>
                    <p>The configuration for Ubuntu 12.04 is just as above, except don't include the &lt;Directory&gt; block in the configuration file.</p>
                    <p>The default site in Apache 2.2.22 is located at /etc/apache2/sites-available/default.</p>
                    <p>Apache 2.2.22 does not have a stable event MPM, so install apache2-mpm-worker instead of apache2-mpm-event.</p>
                </aside>
            </section>
        
            <section id="email">
                <h2>Envio de email</h2>
                <h3>Use <a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a>.</h3>
                <p><em>Tested with <a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> 5.2.7.</em></p>
                <p>PHP provides a <a href="http://php.net/manual/en/function.mail.php">mail()</a> function that looks enticingly simple and easy.  Unfortunately, like a lot of things in PHP, its simplicity is deceptive and using it at face value can lead to serious security problems.</p>
                <p>Email is a set of protocols with an even more tortured history than PHP.  Suffice it to say that there are so many gotchas in sending email that just being in the same room as PHP's mail() function should give you the shivers.</p>
                <p><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer</a> is a popular and well-aged open-source library that provides an easy interface for sending mail securely.  It takes care of the gotchas for you so you can concentrate on more important things.</p>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Include the PHPMailer library
                require_once('phpmailer-5.2.7/PHPMailerAutoload.php');
        
                // Passing 'true' enables exceptions.  This is optional and defaults to false.
                $mailer = new PHPMailer(true);
        
                // Send a mail from Bilbo Baggins to Gandalf the Grey
        
                // Set up to, from, and the message body.  The body doesn't have to be HTML; check the PHPMailer documentation for details.
                $mailer->Sender = 'bbaggins@example.com';
                $mailer->AddReplyTo('bbaggins@example.com', 'Bilbo Baggins');
                $mailer->SetFrom('bbaggins@example.com', 'Bilbo Baggins');
                $mailer->AddAddress('gandalf@example.com');
                $mailer->Subject = 'The finest weed in the South Farthing';
                $mailer->MsgHTML('&lt;p&gt;You really must try it, Gandalf!&lt;/p&gt;&lt;p&gt;-Bilbo&lt;/p&gt;');
        
                // Set up our connection information.
                $mailer->IsSMTP();
                $mailer->SMTPAuth = true;
                $mailer->SMTPSecure = 'ssl';
                $mailer->Port = 465;
                $mailer->Host = 'my smtp host';
                $mailer->Username = 'my smtp username';
                $mailer->Password = 'my smtp password';
        
                // All done!
                $mailer->Send();
                ?&gt;</code>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="https://github.com/PHPMailer/PHPMailer">PHPMailer at Github</a></li>
                </ul> 
            </section>
        
            <section id="validating-emails">
                <h2>Validação de endereços de email</h2>
                <h3>Use a função <a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a>.</h3>
                <p>A common task your web app might need to do is to check if a user has entered a valid email address.  You'll no doubt find online a dizzying range of complex regular expressions that all claim to solve this problem, but the easiest way is to use PHP's built-in <a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a> function, which can validate email addresses.</p>
                
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                filter_var('sgamgee@example.com', FILTER_VALIDATE_EMAIL); // Returns "sgamgee@example.com". This is a valid email address.
                filter_var('sauron@mordor', FILTER_VALIDATE_EMAIL); // Returns boolean false! This is *not* a valid email address.
                ?&gt;</code>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/function.filter-var.php">PHP Manual: filter_var()</a></li>
                    <li><a href="http://php.net/manual/en/filter.filters.php">PHP Manual: Types of filters</a></li>
                </ul>
            </section>
        
            <section id="sanitizing-html">
                <h2>Sanitização de HTML, entrada e saída</h2>
                <h3>Use a função <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> para sanitização simples e a biblioteca <a href="http://htmlpurifier.org/">HTML Purifier</a> para sanitização complexa.</h3>
                <p><em>Tested with <a href="http://htmlpurifier.org/">HTML Purifier</a> 4.6.0.</em></p>
                <p>When displaying user input in any web application, it's essential to "sanitize" it first to remove any potentially dangerous HTML.  A malicious user can craft HTML that, if outputted directly by your web app, can be dangerous to the person viewing it.</p>
                <p>While it may be tempting to use regular expressions to sanitize HTML, <em>do not do this</em>.  HTML is a complex language and it's virtually guaranteed that any attempt you make at using regular expressions to sanitize HTML will fail.</p>
                <p>You might also find advice suggesting you use the <a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a> function.  While strip_tags() is technically safe to use, it's a "dumb" function in the sense that if the input is invalid HTML (say, is missing an ending tag), then strip_tags() might remove much more content than you expected.  As such it's not a great choice either, because non-technical users often use the &lt; and &gt; characters in communications.</p>
                <p>If you read the section on <a href="#validating-emails">validating email addresses</a>, you might also be considering using the <a href="http://php.net/manual/en/function.filter-var.php">filter_var()</a> function.  However <a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">the filter_var() function has problems with line breaks</a>, and requires non-intuitive configuration to closely mirror the <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> function.  As such it's not a good choice either.</p>
        
                <h4>Sanitização para requisitos simples</h4>
                <p>If your web app only needs to completely escape (and thus render harmless, but not remove entirely) HTML, use PHP's built-in <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> function.  This function is much faster than HTML Purifier, because it doesn't perform any validation on the HTML&mdash;it just escapes everything.</p>
                <p>htmlentities() differs from its cousin <a href="http://php.net/manual/en/function.htmlspecialchars.php">htmlspecialchars()</a> in that it encodes <em>all</em> applicable HTML entities, not just a small subset.</p>
    
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
                $evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';
        
                // Use the ENT_QUOTES flag to make sure both single and double quotes are escaped.
                // Use the UTF-8 character encoding if you've stored the text as UTF-8 (as you should have).
                // See the UTF-8 section in this document for more details.
                $safeHtml = htmlentities($evilHtml, ENT_QUOTES, 'UTF-8'); // $safeHtml is now fully escaped HTML.  You can output $safeHtml to your users without fear!
                ?&gt;</code>
        
                <h4>Sanitização para requisitos complexos</h4>
                <p>For many web apps, simply escaping HTML isn't enough.  You probably want to entirely remove any HTML, or allow a small subset of HTML through.  To do this, use the <a href="http://htmlpurifier.org/">HTML Purifier</a> library.</p>
                <p>HTML Purifier is a well-tested but slow library.  That's why you should use <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> if your requirements aren't that complex, because it will be much, much faster.</p>
                <p>HTML Purifier has the advantage over <a href="http://php.net/manual/en/function.strip-tags.php">strip_tags()</a> because it validates the HTML before sanitizing it.  That means if the user has inputted invalid HTML, HTML Purifier has a better chance of preserving the intended meaning of the HTML than strip_tags() does.  It's also highly customizable, allowing you to whitelist a subset of HTML to keep in the output.</p>
                <p>The downside is that it's quite slow, it requires some setup that might not be feasible in a shared hosting environment, and the documentation is often complex and unclear.  The following example is a basic configuration; check the <a href="http://htmlpurifier.org/docs">documentation</a> to read about the more advanced features HTML Purifier offers.</p>
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Include the HTML Purifier library
                require_once('htmlpurifier-4.6.0/HTMLPurifier.auto.php');
        
                // Oh no!  The user has submitted malicious HTML, and we have to display it in our web app!
                $evilHtml = '&lt;div onclick="xss();"&gt;Mua-ha-ha!  Twiddling my evil mustache...&lt;/div&gt;';
        
                // Set up the HTML Purifier object with the default configuration.
                $purifier = new HTMLPurifier(HTMLPurifier_Config::createDefault());
        
                $safeHtml = $purifier->purify($evilHtml); // $safeHtml is now sanitized.  You can output $safeHtml to your users without fear!
                ?&gt;</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>Using htmlentities() with the wrong character encoding can result in surprising output.  Always make sure that you specify a character encoding when calling the function, and that it matches the encoding of the string being sanitized.  See the <a href="#utf-8">UTF-8 section</a> for more details.</li>
                    <li>Always include the ENT_QUOTES and character encoding parameters when using htmlentities().  By default, htmlentities() doesn't encode single quotes.  What a dumb default!</li> 
                    <li>HTML Purifier is extremely slow for complex HTML.  Consider setting up a caching solution like <a href="#opcode-cache">APC</a> to store the sanitized result for later use.</li>
                </ul>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://htmlpurifier.org/comparison">Comparison between PHP HTML sanitizers</a></li>
                    <li><a href="http://stackoverflow.com/questions/3605629/php-prevent-xss-with-strip-tags">Stack Overflow: Prevent XSS with strip_tags()?</a></li>
                    <li><a href="http://stackoverflow.com/questions/129677/whats-the-best-method-for-sanitizing-user-input-with-php">Stack Overflow: What's the best method for sanitizing user input with PHP?</a></li>
                    <li><a href="http://stackoverflow.com/questions/3150413/filter-sanitize-special-chars-problem-with-line-breaks">Stack Overflow: FILTER_SANITIZE_SPECIAL_CHARS problem with line breaks</a></li>
                </ul>
            </section>
        
            <section id="utf-8">
                <h2>PHP e UTF-8</h2>
                <h3>Não existe uma solução curta. Seja cuidadoso, detalhista e consistente.</h3>
                <p>UTF-8 in PHP sucks.  Sorry.</p>
                <p>Right now PHP does not support Unicode at a low level.  There are ways to ensure that UTF-8 strings are processed OK, but it's not easy, and it requires digging in to almost all levels of the web app, from HTML to SQL to PHP.  We'll aim for a brief, practical summary.</p>
                
                <h4>UTF-8 no nível do PHP</h4>
                <p>The basic <a href="http://php.net/manual/en/language.operators.string.php">string operations</a>, like concatenating two strings and assigning strings to variables, don't need anything special for UTF-8.  However most <a href="http://php.net/manual/en/ref.strings.php">string functions</a>, like <a href="http://php.net/manual/en/function.strpos.php">strpos()</a> and <a href="http://php.net/manual/en/function.strlen.php">strlen()</a>, <em>do</em> need special consideration.  These functions often have an mb_* counterpart: for example, <a href="http://php.net/manual/en/function.mb-strpos.php">mb_strpos()</a> and <a href="http://php.net/manual/en/function.mb-strlen.php">mb_strlen()</a>.  Together, these counterpart functions are called the <a href="http://php.net/manual/en/ref.mbstring.php">Multibyte String Functions</a>.  The multibyte string functions are specifically designed to operate on Unicode strings.</p>
                <p>You <em>must</em> use the mb_* functions whenever you operate on a Unicode string.  For example, if you use <a href="http://php.net/manual/en/function.substr.php">substr()</a> on a UTF-8 string, there's a good chance the result will include some garbled half-characters.  The correct function to use would be the multibyte counterpart, <a href="http://php.net/manual/en/function.mb-substr.php">mb_substr()</a>.</p>
                <p>The hard part is remembering to use the mb_* functions <em>at all times</em>.  If you forget even just once, your Unicode string has a chance of being garbled during further processing.</p>
                <p>Not all string functions have an mb_* counterpart.  If there isn't one for what you want to do, then you might be out of luck.</p>
                <p>Additionally, you should use the <a href="http://php.net/manual/en/function.mb-internal-encoding.php">mb_internal_encoding()</a> function at the top of every PHP script you write (or at the top of your global include script), and the <a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a> function right after it if your script is outputting to a browser.  Explicitly defining the encoding of your strings in every script will save you a lot of headaches down the road.</p>
                <p>Finally, many PHP functions that operate on strings have an optional parameter letting you specify the character encoding.  You should always explicitly indicate UTF-8 when given the option.  For example, <a href="http://php.net/manual/en/function.htmlentities.php">htmlentities()</a> has an option for character encoding, and you should <em>always</em> specify UTF-8 if dealing with such strings.</p>
        
                <h4>UTF-8 no nível do MySQL</h4>
                <p>If your PHP script accesses MySQL, there's a chance your strings could be stored as non-UTF-8 strings in the database even if you follow all of the precautions above.</p>
                <p>To make sure your strings go from PHP to MySQL as UTF-8, make sure your database and tables are all set to the utf8mb4 character set and collation, and that you use the utf8mb4 character set in the PDO connection string.  For an example, see the section on <a href="#mysql">connecting to and querying a MySQL database</a>.  This is <em>critically important</em>.</p>
                <p>Note that you must use the `utf8mb4` character set for complete UTF-8 support, <em>not</em> the `utf8` character set!  See <a href="#utf8-further-reading">Mais informações</a> for why.</p>

                <h4>UTF-8 no nível do navegador</h4>
                <p>Use the <a href="http://php.net/manual/en/function.mb-http-output.php">mb_http_output()</a> function to ensure that your PHP script outputs UTF-8 strings to your browser.  In your HTML, include the <a href="http://htmlpurifier.org/docs/enduser-utf8.html">charset &lt;meta&gt; tag</a> in your page's &lt;head&gt; tag.
        
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Tell PHP that we're using UTF-8 strings until the end of the script
                mb_internal_encoding('UTF-8');
        
                // Tell PHP that we'll be outputting UTF-8 to the browser
                mb_http_output('UTF-8');
        
                // Our UTF-8 test string
                $string = 'Êl síla erin lû e-govaned vîn.';
        
                // Transform the string in some way with a multibyte function
                // Note how we cut the string at a non-Ascii character for demonstration purposes
                $string = mb_substr($string, 0, 15);
        
                // Connect to a database to store the transformed string
                // See the PDO example in this document for more information
                // Note that we define the character set as utf8mb4 in the PDO connection string
                $link = new \PDO(   'mysql:host=your-hostname;dbname=your-db;charset=utf8mb4',
                                    'your-username',
                                    'your-password',
                                    array(
                                        \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
                                        \PDO::ATTR_PERSISTENT => false
                                    )
                                );
                
                // Store our transformed string as UTF-8 in our database
                // Your DB and tables are in the utf8mb4 character set and collation, right?
                $handle = $link->prepare('insert into ElvishSentences (Id, Body) values (?, ?)');
                $handle->bindValue(1, 1, PDO::PARAM_INT);
                $handle->bindValue(2, $string);
                $handle->execute();
                
                // Retrieve the string we just stored to prove it was stored correctly
                $handle = $link->prepare('select * from ElvishSentences where Id = ?');
                $handle->bindValue(1, 1, PDO::PARAM_INT);
                $handle->execute();
                
                // Store the result into an object that we'll output later in our HTML
                $result = $handle->fetchAll(\PDO::FETCH_OBJ);
                ?&gt;&lt;!doctype html&gt;
                &lt;html&gt;
                    &lt;head&gt;
                        &lt;meta charset="UTF-8" /&gt;
                        &lt;title&gt;UTF-8 test page&lt;/title&gt;
                    &lt;/head&gt;
                    &lt;body&gt;
                        &lt;?php
                        foreach($result as $row){
                            print($row->Body);  // This should correctly output our transformed UTF-8 string to the browser
                        }
                        ?&gt;
                    &lt;/body&gt;
                &lt;/html&gt;</code>
        
                <h4 id="utf8-further-reading">Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/ref.mbstring.php">PHP Manual: Multibyte String Functions</a></li>
                    <li><a href="http://blog.loftdigital.com/blog/php-utf-8-cheatsheet">PHP UTF-8 Cheatsheet</a></li>
                    <li><a href="http://stackoverflow.com/questions/571694/what-factors-make-php-unicode-incompatible">Stack Overflow: What factors make PHP Unicode-incompatible?</a></li>
                    <li><a href="http://stackoverflow.com/questions/140728/best-practices-in-php-and-mysql-with-international-strings">Stack Overflow: Best practices in PHP and MySQL with international strings</a></li>
                    <li><a href="http://mathiasbynens.be/notes/mysql-utf8mb4">How to support full Unicode in MySQL databases</a></li>
                </ul>
            </section>
            
            <section id="working-with-dates-and-times">
                <h2>Trabalhando com datas e horários</h2>
                <h3>Use a classe <a href="http://www.php.net/manual/en/class.datetime.php">DateTime</a>.</h3>
                <p>In the bad old days of PHP we had to work with dates and times using a bewildering combination of <a href="http://www.php.net/manual/en/function.date.php">date()</a>, <a href="http://www.php.net/manual/en/function.gmdate.php">gmdate()</a>, <a href="http://www.php.net/manual/en/function.date-timezone-set.php">date_timezone_set()</a>, <a href="http://www.php.net/manual/en/function.strtotime.php">strtotime()</a>, and so on. Sadly you'll still find lots of tutorials online featuring these difficult and old-fashioned functions.</p>
                <p>Fortunately for us, the version of PHP we're talking about features the much friendlier <a href="http://www.php.net/manual/en/class.datetime.php">DateTime class</a>. This class encapsulates all the functionality <em>and more</em> of the old date functions in one easy-to-use class, with the bonus of making time zone conversions much simpler. Always use the DateTime class for creating, comparing, changing, and displaying dates in PHP.</p>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                // Construct a new UTC date.  Always specify UTC unless you really know what you're doing!
                $date = new DateTime('2011-05-04 05:00:00', new DateTimeZone('UTC'));

                // Add ten days to our initial date
                $date->add(new DateInterval('P10D'));

                echo($date->format('Y-m-d h:i:s')); // 2011-05-14 05:00:00

                // Sadly we don't have a Middle Earth timezone
                // Convert our UTC date to the PST (or PDT, depending) time zone
                $date->setTimezone(new DateTimeZone('America/Los_Angeles'));

                // Note that if you run this line yourself, it might differ by an hour depending on daylight savings
                echo($date->format('Y-m-d h:i:s')); // 2011-05-13 10:00:00

                $later = new DateTime('2012-05-20', new DateTimeZone('UTC'));

                // Compare two dates
                if($date &lt; $later)
                    echo('Yup, you can compare dates using these easy operators!');

                // Find the difference between two dates
                $difference = $date->diff($later);

                echo('The 2nd date is ' . $difference['days'] . ' later than 1st date.');
                ?&gt;
                </code>
                
                <h4>Pegadinhas</h4>
                <ul>
                    <li><p>If you don't specify a time zone, <a href="http://www.php.net/manual/en/datetime.construct.php">DateTime::__construct()</a> will set the resulting date's time zone to <em>the time zone of the computer you're running on</em>. This can lead to spectacular headaches later on. <strong>Always specify the UTC time zone when creating new dates unless you really know what you're doing.</strong></p></li>
                    <li><p>If you use a Unix timestamp in DateTime::__construct(), the time zone will always be set to UTC regardless of what you specify in the second argument.</p></li>
                    <li><p>Passing zeroed dates (e.g. &quot;0000-00-00&quot;, a value commonly produced by MySQL as the default value in a DateTime column) to DateTime::__construct() will result in a nonsensical date, not &quot;0000-00-00&quot;.</p></li>
                    <li><p>Using <a href="http://www.php.net/manual/en/datetime.gettimestamp.php">DateTime::getTimestamp()</a> on 32-bit systems will not represent dates past 2038. 64-bit systems are OK.</p></li>
                </ul>
                
                <h4>Mais informações</h4>
                <ul>
                    <li><p><a href="http://www.php.net/manual/en/book.datetime.php">PHP Manual: The DateTime class</a></p></li>
                    <li><p><a href="http://stackoverflow.com/questions/5319710/accessing-dates-in-php-beyond-2038">Stack Overflow: Accessing dates beyond 2038</a></p></li>
                </ul>
            </section>
            
            <section id="checking-for-null">
                <h2>Verificando se um valor é null ou false</h2>
                <h3>Use o operador <a href="http://php.net/manual/en/language.operators.comparison.php">===</a> para verificar valores null e o boleano false.</h3>
                <p>PHP's loose typing system offers many different ways of checking a variable's value.  However it also presents a lot of problems.  Using <a href="http://php.net/manual/en/language.operators.comparison.php">==</a> to check if a value is null or false can return false positives if the value is actually an empty string or 0. <a href="http://php.net/manual/en/function.isset.php">isset()</a> checks whether a variable has a value, <em>not</em> whether that value is null or false, so it's not appropriate to use here.</p>
                <p>The <a href="http://php.net/manual/en/function.is-null.php">is_null()</a> function accurately checks if a value is null, and the <a href="http://php.net/manual/en/function.is-bool.php">is_bool()</a> function checks if it's a boolean value (like false), but there's an even better option: the <a href="http://php.net/manual/en/language.operators.comparison.php">===</a> operator.  === checks if the values are <em>identical</em>, which is not the same as <em>equivalent</em> in PHP's loosely-typed world.  It's also slightly faster than is_null() and is_bool(), and can be considered by some to be cleaner than using a function for comparison.</p>
            
                <h4>Exemplo</h4>
                <code class="php">
                &lt;?php
                $x = 0;
                $y = null;
        
                // Is $x null?
                if($x == null)
                    print('Oops! $x is 0, not null!');
            
                // Is $y null?
                if(is_null($y))
                    print('Great, but could be faster.');
            
                if($y === null)
                    print('Perfect!');
        
                // Does the string abc contain the character a?
                if(strpos('abc', 'a'))
                    // GOTCHA!  strpos returns 0, indicating it wishes to return the position of the first character.
                    // But PHP interpretes 0 as false, so we never reach this print statement!
                    print('Found it!'); 
        
                //Solution: use !== (the opposite of ===) to see if strpos() returns 0, or boolean false.   
                if(strpos('abc', 'a') !== false)
                    print('Found it for real this time!');
                ?&gt;</code>
        
                <h4>Pegadinhas</h4>
                <ul>
                    <li>When testing the return value of a function that can return either 0 or boolean false, like strpos(), always use === and !==, or you'll run in to problems.</li>
                </ul>
        
                <h4>Mais informações</h4>
                <ul>
                    <li><a href="http://php.net/manual/en/language.operators.comparison.php">PHP Manual: Comparison operators</a></li>
                    <li><a href="http://stackoverflow.com/questions/8228837/is-nullx-vs-x-null-in-php">Stack Overflow: is_null() vs ===</a></li>
                </ul>
            </section>
        
            <section id="suggestions">
                <h2>Sugestões e correções</h2>
                <p>Thanks for reading!  If you haven't figured it out already, PHP is complex and filled with pitfalls.  Since I'm only human, there might be mistakes in this document.</p>
                <p>If you'd like to contribute to this document with suggestions or corrections, please contact me using the information in the <a href="#maintainers">last revised &amp; maintainers</a> section.</p>
            </section>
        </article>
        
        <footer>
            <p>
                <a href="/">PHP Melhores Práticas</a> por <a rel="author" href="https://alexcabal.com">Alex Cabal</a> e suas traduções são liberadas em <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.pt_BR">domínio público</a>.  <a href="https://alexcabal.com/why-i-release-things-into-the-public-domain/">Por que?</a>
            </p>
            <p>
                <a href="/">PHP Best Practices</a> by <a rel="author" href="https://alexcabal.com">Alex Cabal</a> and its translations are released into the <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">public domain</a>.  <a href="https://alexcabal.com/why-i-release-things-into-the-public-domain/">Why?</a>
            </p>
        </footer>
    </body>
</html>
